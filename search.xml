<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Spring Boot Actuator 를 이용해 버전 정보 제공하기</title>
      <link href="/2018/03/24/spring-boot-actuator/"/>
      <url>/2018/03/24/spring-boot-actuator/</url>
      <content type="html"><![CDATA[<h3><span id="지금-dev-서버에-배포되어-있는-서버-버전이-몇인가요">지금 dev 서버에 배포되어 있는 서버 버전이 몇인가요?</span></h3><p>회사에 서버환경은 dev, sandbox, test, beta, alpha, real 으로 나뉘어 있다. 각 단계별로 기능 테스트를 하고 QA를 통해 모든 기능이 개발 완료 되고 QA도 끝나면 real 서버에 배포가 된다.<br>나와 클라이언트 개발자는 먼저 dev 서버에서 새로운 기능이나 버그 수정등을 테스트 하는데 일정에 쫓길 때는 메이져 버전과 마이너 버전이 동시에 작업되서 두개의 버전을 두고 개발해야 하는 상황이 생기기도 한다.<br>젠킨스를 통해 해당 서버에 어플리케이션을 배포하는데 지금까지는 배포된 버전을 보기 위해선 젠킨스의 배포이력을 찾아 배포된 버전을 찾았어야 했었다. 여간 귀찮은 일이 아닐 수가 없다. 하지만 이 방법밖에는 없으니 얼른 클라이언트 개발자에게 현재 배포된 버전을 찾아서 알려주자.<br><code>build.gradle</code> 에 배포된 버전을 명시해놓고 있긴 하지만 jar로 묶인 패키지에는 버전을 알 수 있는 방법이 없다. 이런 설정정보들을 쉽게 확인할 수 있었으면 좋겠다.</p><h3><span id="지금-필요한-기능과-제약을-정리해보자">지금 필요한 기능과 제약을 정리해보자.</span></h3><p>처음엔 무작정 덤벼들까도 했지만 침착하게 숨을 고르고 내가 해야할 일을 정리해보았다.</p><ul><li>배포되는 서버환경별로 어플리케이션의 버전정보를 알고 싶다.</li><li>알기 쉽게 endpoint등의 방법으로 버전을 알려주고 싶다.</li><li>모듈이 여러개가 있기 때문에 현재 돌아가고 있는 어플리케이션의 이름정보등 여러가지를 알고 싶다.</li></ul><h2><span id="프로젝트의-구조를-살펴보자">프로젝트의 구조를 살펴보자</span></h2><p>spring-boot 로 구성된 프로젝트는 여러개의 모듈로 구성되어 있다. 각 프로젝트별로 기능들을 모아놓고 있으며 jar로 묶여 runnable한 모듈도 있고 common 이나 utils 같이 기능들을 모아놓은 모듈도 있다.<br>프로젝트의 설정은 아래와 같이 구성되어 있다.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── api</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── batch</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── build.gradle</span><br><span class="line">├── common</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── elasticsearch</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">├── mongodb</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── mysql</span><br><span class="line">│   ├── build</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── redis</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── settings.gradle</span><br><span class="line">└── utils</span><br><span class="line">    ├── build.gradle</span><br><span class="line">    └── src</span><br></pre></td></tr></table></figure><p>runnable한 모듈들의 <code>build.gradle</code> 에는 각자 버전들이 명시되어 있다. <code>api</code> 모듈의 <code>build.gradle</code>을 살펴보자.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'rebel'</span></span><br><span class="line">apply plugin: <span class="string">'org.springframework.boot'</span></span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    baseName = <span class="string">'api'</span></span><br><span class="line">    version = <span class="string">'9.2.8-SNAPSHOT'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':common'</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':mysql'</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':mongodb'</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':redis'</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':utils'</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':elasticsearch'</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bootRun &#123;</span><br><span class="line">    systemProperties System.properties</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ext</code> 안에 모듈의 이름과 관리되고 있는 버전의 정보가 들어있다. 어떤 기능이 개발되어 질 때는 버전을 먼저 따고 그 버전에 기능들 개발해 넣게 된다. 클라이언트 개발자들과의 소통은 저 버전으로 하게 된다.<br>하지만 빌드를 하면 저 정보는 jar에 따라 오지 않기 때문에 jar파일만 가지고는 버전정보를 알 수가 없다. 안되는게 어디있는가 이제부터 저 정보들을 제공하는 방법들을 알아보도록 하자.</p><h2><span id="spring-boot-actuator">Spring boot actuator</span></h2><p>spring boot 에서 제공하고 있는 공식 모듈중에 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready" rel="external nofollow noopener noreferrer" target="_blank">spring boot actuator</a> 라는 모듈이 있다. 이게 무엇인고 하고 살펴보니 아래와 같이 정의가 되어 있다.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Definition <span class="keyword">of</span> Actuator</span><br><span class="line"></span><br><span class="line">An actuator is <span class="keyword">a</span> manufacturing term that refers <span class="built_in">to</span> <span class="keyword">a</span> mechanical device <span class="keyword">for</span> moving <span class="keyword">or</span> controlling something.   </span><br><span class="line">Actuators can generate <span class="keyword">a</span> large amount <span class="keyword">of</span> motion <span class="built_in">from</span> <span class="keyword">a</span> small change.</span><br></pre></td></tr></table></figure><p>여러 정보들을 작은 작업으로 제공해준다니 내가 찾고 있던 것이 틀림없다. 기본적으로 여러 endpoint 들을 제공하고 있고 info 뿐만 아니라 health 나 metrics 등 여러 기능들을 제공하고 있다. 지금 필요한건 버전에 대한 정보들만 표시할 수있으면 되기 때문에 옆길로 새지말고 직진하도록 하자.<br>아무런 설정을 하고 않고 빌드를 하게 되면 build.gradle 에 명시되어 있는 버전 정보들은 빠지고 빌드가 되게 된다. actuator 을 추가해보자.</p><p><code>build.gradle</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line">ext &#123;</span><br><span class="line">   baseName = <span class="string">'api'</span></span><br><span class="line">   version = <span class="string">'9.2.8-SNAPSHOT'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">compile <span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">springBoot&#123;</span><br><span class="line">    buildInfo &#123;</span><br><span class="line">        additionalProperties = [</span><br><span class="line">                <span class="string">'version'</span>: <span class="string">"<span class="subst">$&#123;project.ext.version&#125;</span>"</span>,</span><br><span class="line">                <span class="string">'name'</span>: <span class="string">"<span class="subst">$&#123;project.ext.baseName&#125;</span>"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>ext</code>에는 해당 모듈의 이름과 버전 정보가 들어가게 된다. 클라이언트와 QA가 원하는 값은 저 버전 정보이다.</li><li>모듈을 추가만 해주면 끝이다. 이제 여러 정보들을 endpoint로 제공받을 수 있다. 하지만 이번 포스팅에서는 다른 기능들을 알아보는건 스킵하도록 한다. (조금 써보았는데 굉장히 많은 정보들을 제공해주고 있다. 나중에 좀 더 깊게 살펴보는게 좋겠다.)</li><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-build-info" rel="external nofollow noopener noreferrer" target="_blank">buildInfo</a> 값을 넣어주면 gradle 로 빌드할 때 기본적인 빌드 정보들을 <code>build-info.properties</code> 파일 안에 적어주는데 추가적인 정보들을 넣어줄 수 있다.</li></ol><p>이제 빌드를 해서 결과값을 살펴보자. <code>build/resources/main/META-INF/build-info.properties</code> 안에 buildInfo의 기본적인 값들과 추가적으로 기술해준 정보들이 아래와 같이 들어가있다.</p><p><code>build-info.properties</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Properties</span></span><br><span class="line"><span class="comment">#Sat Mar 24 16:17:58 KST 2018</span></span><br><span class="line">build.<span class="attribute">time</span>=2018-03-24T16\:17\:58+0900</span><br><span class="line">build.<span class="attribute">artifact</span>=api</span><br><span class="line">build.<span class="attribute">group</span>=teddy</span><br><span class="line">build.<span class="attribute">name</span>=api</span><br><span class="line">build.<span class="attribute">version</span>=9.2.8</span><br></pre></td></tr></table></figure><h3><span id="dev-서버에-배포된-버전은-928입니다">dev 서버에 배포된 버전은 9.2.8입니다.</span></h3><p>값이 잘 들어와있음을 확인했다. 이제 actuator에서 제공하는 endpoint <code>info</code>로 이 값들을 확인할 수 있다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> &gt; curl localhost:8080/info</span></span><br><span class="line">&#123;</span><br><span class="line">"build":&#123;</span><br><span class="line">"version":"9.2.8-SNAPSHOT",</span><br><span class="line">"artifact":"teddy",</span><br><span class="line">"name":"api",</span><br><span class="line">"group":"com.nevercaution",</span><br><span class="line">"time":1521877296000</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>설정과 적용이 완료 되었다. 이제 어느 누가 서버의 버전을 묻는다면 버벅이지 말고 자신있게 버전을 알려주도록 하자.</p><h2><span id="결론">결론</span></h2><p>요즘 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready" rel="external nofollow noopener noreferrer" target="_blank">spring boot reference guide</a> 를 읽고 있는데 개인적인 느낌으로는 <a href="https://docs.djangoproject.com/en/2.0/" rel="external nofollow noopener noreferrer" target="_blank">django document</a> 보다 훨씬 상세하고 직관적으로 문서를 작성해놓았다고 생각한다. <s>django문서보면서 추상적인 표현에 적잖이 당황했었다</s><br>그리고 spring boot starter 에 많은 기능들이 있어 따로 작업해야 하는 부분이 줄어들었고 적용도 간단히 된다.<br>조금 뜬금없는 생각이지만 spring boot 모듈을 한번쯤은 만들어 봐야 겠다는 생각이 들었다.</p>]]></content>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> gradle </tag>
            
            <tag> spring-boot-actuator </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-boot 에서 Elasticsearch java rest client 사용하기</title>
      <link href="/2018/03/15/elasticsearch-rest-client/"/>
      <url>/2018/03/15/elasticsearch-rest-client/</url>
      <content type="html"><![CDATA[<h3><span id="elasticsearch-버전을-올려야-한다">elasticsearch 버전을 올려야 한다.</span></h3><p>검색 서비스를 개선하면서 사내에서 elasticsearch 를 사용하고 있다.<br>처음에 사용했던 버전은 개발 당시의 가장 최근 버전인 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.1/index.html" rel="external nofollow noopener noreferrer" target="_blank">elasticsearch 5.1.1</a> 버전이다.<br>spring boot 에 연동했는데 <a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-elasticsearch" rel="external nofollow noopener noreferrer" target="_blank">spring-boot-data-elasticsearch-starter</a> 는 (글을 작성하는) 아직까지도 2.x 버전만 지원하고 있어 직접 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.1/client.html" rel="external nofollow noopener noreferrer" target="_blank">client</a> 를 붙이기로 했다.</p><p>개인적인 생각으로는 나중에 개발이 되어질 spring-boot-data-elasticsearch-starter 로 재구현해도 되긴 하겠지만 elasticsearch를 사용하면서 느낀점은 굳이 starter를 사용할 필요는 없다고 생각한다.<br>repository와 model로 나뉘어 orm처럼 사용하면 편하기야 할테지만 직접 쿼리를 만들면서 튜닝하는 부분이 재미있기도 하고 좀 더 세세하게 만질 수 있다고 생각하기 때문이다.</p><p>elasticsearch 는 버전업이 빠른 편이다. 6.x 도 꾸준히 올라가는 추세고 곧있으면 7.x 이 나오고 9.x 까지 로드맵이 그려져 있다. 다행히 5.1.x 버전대에서 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/rolling-upgrades.html" rel="external nofollow noopener noreferrer" target="_blank">rolling upgrade</a> 가 가능하기 때문에 5.x 의 마지막 버전인 5.6.8 까지 따라 올라가야 겠다고 생각했다. 그러다가 문득 <a href="https://www.elastic.co/blog/state-of-the-official-elasticsearch-java-clients" rel="external nofollow noopener noreferrer" target="_blank">State of the official Elasticsearch Java Clients</a> 라는 포스팅을 보게 되었다. 처음에 java client 를 붙이려면 공식 문서에서는 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.1/transport-client.html" rel="external nofollow noopener noreferrer" target="_blank">transport client</a> 로 연동하도록 안내한다. 하지만 위의 포스팅의 여러 문제점으로 인해 앞으로는 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/6.2/client.html" rel="external nofollow noopener noreferrer" target="_blank">Rest client 를 사용하도록 권장하고 있다.</a></p><p>Java Rest Client 는 두가지 방식이 있다.</p><ul><li>Java Low Level REST Client</li><li>Java High Level REST Client</li></ul><p>low level 에서는 요청을 직접 만들어서 호출하는 방식인데, 나는 high level로 작업하기로 했다.<br>(참고로 rest client는 5.6부터 제공되었다.)</p><h3><span id="서론이-조금-길었다">서론이 조금 길었다.</span></h3><p>내가 elasticsearch 버전을 올리기로 생각한 이유는 <a href="https://www.elastic.co/support/eol" rel="external nofollow noopener noreferrer" target="_blank">elasticsearch 기술 지원</a> 때문이다.<br>내가 사용하고 있는 5.1.x 는 2018-06-08 까지만 공식지원을 하고 있다.<br>물론 공식 지원이 끊기더라도 검색 서비스를 구동함에는 큰 지장은 없지만, 메이져 버전이 두개 이상 차이가 나게 되었을 때 버전을 올려야 하는 상황이 오면 rolling upgrade도  사용할 수 없기 때문에 이참에 6.2 로 올라가기로 마음먹었다. 현재 버전에서 한번에 올라가는건 안되기 때문에 다음과 같이 버전올림 순서를 정하기로 했다.</p><h2><span id="업데이트-순서">업데이트 순서</span></h2><ol><li>elasticsearch 5.1.1 -&gt; 5.6.8 로 rolling upgrade</li><li>spring-boot elasticsearch java client 5.1.1 -&gt; 5.6.8 로 업데이트 후 배포</li><li>elasticsearch 5.6.8 -&gt; 6.2.2 로 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-upgrade.html" rel="external nofollow noopener noreferrer" target="_blank">rolling upgrade</a></li><li>spring-boot elasticsearch java client 5.6.8 -&gt; 6.2.2 로 업데이트 후 배포</li></ol><p><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/java-rest-high-compatibility.html" rel="external nofollow noopener noreferrer" target="_blank">메이져 버전별로의 호환성</a>에 따라 5.x 버전끼리는 문제없이 통신을 할 수 있다. 물론 6.x 끼리의 버전도 문제가 없었는데, 테스트 결과 5.6.8 에서 6.2.2 도 호출이 가능했다.<br>클라이언트를 보니 모든 기능을 사용할 수 있지는 않고 부분적인 기능들만 사용가능할 것으로 보인다. 그리고 상위 버전 호환은 괜찮아도 하위 버전 호환은 기능이 구현되지 않을 가능성이 있어 문제의 여지가 있다.</p><h3><span id="rolling-upgrade">rolling upgrade</span></h3><p>현재 사용하고 있는 rolling upgrade 스크립트이다. 구글링 해보니 좀 더 유려한 스크립트 들이 많이 있는데 나는 간단한 동작들만 사용하는 중이다.</p><p>일단 구동중인 es를 내린다.<br><code>shut_down.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># disable shard allocation</span></span><br><span class="line">curl -XPUT <span class="string">'localhost:9200/_cluster/settings?pretty=true'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "transient" : &#123;</span></span><br><span class="line"><span class="string">        "cluster.routing.allocation.enable" : "none"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shutdown</span></span><br><span class="line">sudo service elasticsearch stop</span><br></pre></td></tr></table></figure><p>정상적으로 내려간 것을 확인한 후 elasticsearch 버전을 올려 재설치하도록 한다. 그리고 다시 구동시켜 주자.</p><p><code>start.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">sudo service elasticsearch start</span><br><span class="line"></span><br><span class="line">STATUS=<span class="string">""</span></span><br><span class="line"><span class="keyword">while</span> ! [[ <span class="string">"<span class="variable">$STATUS</span>"</span> =~ (\<span class="string">"tagline\" : \"You Know, for Search\") ]];</span></span><br><span class="line"><span class="string">do</span></span><br><span class="line"><span class="string">    echo "</span>fetching http://localhost:9200<span class="string">"</span></span><br><span class="line"><span class="string">    STATUS=`curl -sS -XGET http://localhost:9200`</span></span><br><span class="line"><span class="string">    sleep 1</span></span><br><span class="line"><span class="string">done</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">curl -XPUT 'localhost:9200/_cluster/settings?pretty=true' -d '&#123;</span></span><br><span class="line"><span class="string">    "</span>transient<span class="string">" : &#123;</span></span><br><span class="line"><span class="string">        "</span>cluster.routing.allocation.enable<span class="string">" : "</span>all<span class="string">"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><p>자 이제 버전도 올렸으니 client 를 변경해보도록 하자.</p><h2><span id="client-에서-rest-client">client 에서 rest client</span></h2><p>위에서 설명한 것과 같이 앞으로는 rest client 를 써야만 하는 시점이 온다.<br>지금 당장은 바꾸지 않아도 되지만 (완성이 되지 않아 할 수도 없지만) 어떻게 바뀌는지 느낌만 살펴보자.<br>기존에 transport layer로 붙는 client를 rest client로 변경하는 작업을 해보자. 일단 설정부터 변경해야 한다.</p><h3><span id="setting">setting</span></h3><p><code>build.gradle</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'org.elasticsearch:elasticsearch:6.2.2'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'org.elasticsearch.client:elasticsearch-rest-high-level-client:6.2.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 기존에 붙었던 <code>9300</code>포트가 아닌 <code>9200</code>포트로 접속해야 한다.<br><code>application.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">elasticsearch:</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">host1.com,</span> <span class="string">host2.com</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9200</span></span><br></pre></td></tr></table></figure><h3><span id="configuration">configuration</span></h3><p>설정파일을 고쳤으면 configuration쪽을 손봐주도록 하자.<br>기존의 config와 비교를 해보면 다음과 같다.</p><p><code>기존 ElascitsearchConfig.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;'$&#123;elasticsearch.hosts&#125;'.split(',')&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hosts;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;elasticsearch.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">client</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Settings settings = Settings.builder()</span><br><span class="line">                .put(<span class="string">"client.transport.sniff"</span>, <span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        PreBuiltTransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">        <span class="keyword">for</span>(String host : hosts) &#123;</span><br><span class="line">            InetSocketTransportAddress item = <span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(host), port);</span><br><span class="line">            client.addTransportAddresses(item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>변경된 ElascitsearchConfig.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;'$&#123;elasticsearch.hosts&#125;'.split(',')&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hosts;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;elasticsearch.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">getRestClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;HttpHost&gt; hostList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String host : hosts) &#123;</span><br><span class="line">            hostList.add(<span class="keyword">new</span> HttpHost(host, port, <span class="string">"http"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RestClientBuilder builder = RestClient.builder(hostList.toArray(<span class="keyword">new</span> HttpHost[hostList.size()]));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestHighLevelClient(builder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="service">service</span></h3><p>약간씩 달라진 부분들을 살펴보자. 큰틀은 변경되진 않았고 호출하는 클래스나 메소드들이 조금씩 변경되었다.<br>개인 적인 느낌으로는 각 클래스별로 역할이 좀 더 충실해졌다고 생각이 들었다.</p><p><code>create</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">Client client;</span><br><span class="line">IndicesAdminClient adminClient = client.admin().indices();</span><br><span class="line">CreateIndexResponse createIndexResponse = adminClient.prepareCreate(<span class="string">"index_name"</span>)</span><br><span class="line">            .setSettings(seriesSettings())</span><br><span class="line">            .addMapping(<span class="string">"type name"</span>, seriesIndex()).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">RestHighLevelClient client;</span><br><span class="line">CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">"index_name"</span>);</span><br><span class="line">request.settings(seriesSettings(), XContentType.JSON);</span><br><span class="line">request.mapping(<span class="string">"type_name"</span>, seriesIndex(), XContentType.JSON);</span><br><span class="line">client.indices().create(request);</span><br></pre></td></tr></table></figure><p><code>search query</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common</span></span><br><span class="line">QueryBuilder qb = QueryBuilders.matchQuery(<span class="string">"text"</span>, text);</span><br><span class="line"></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line">Client client;</span><br><span class="line">SearchResponse response = client.prepareSearch(<span class="string">"index_name"</span>).setTypes(<span class="string">"type_name"</span>).setQuery(qb).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">RestHighLevelClient client;</span><br><span class="line">SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder().query(qb);</span><br><span class="line">SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"index_name"</span>).types(<span class="string">"type_name"</span>).source(searchSourceBuilder);</span><br><span class="line">SearchResponse response = client.search(searchRequest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// common</span></span><br><span class="line">response.getHits().forEach(item -&gt; &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>간단하게 index 를 만들고 검색하는 부분까지의 메소드들을 보았다. 나는 여기에 추가로 alias, exists, multi_search 등을 사용하고 있지만 아직까지 6.2.x 에는 해당 메소드가 없다. 어떻게든 해보려고 엔진소스를 들어가서 한참을 살펴보다가 혹시나 해서 master 브랜치를 받아보니 해당 메소드들이 있더라… (현재 master 브랜치의 버전은 7.0.0-alpha1 이다.)</p><h2><span id="결론">결론</span></h2><p>미리 적용을 해놓을까 해서 버전별로 소스를 살펴 보았지만 아직까지 모든 메소드들이 구현되어 있지 않기도 하고 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.6/client.html" rel="external nofollow noopener noreferrer" target="_blank">java client가 없어지려면 8.0 까지 올라가야 하니</a> 아직은 조금 여유가 있어보인다.<br>그래도 버전이 올라가는 속도를 보면 7.0 메이져 버전이 나오고 rest client가 완성이 되었을 때 슬슬 적용하면 될 것 같다. <s>세수하러 왔다가 물만 먹고 가는 느낌</s></p>]]></content>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> elasticsearch </tag>
            
            <tag> restclient </tag>
            
            <tag> javaclient </tag>
            
            <tag> transportlyer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring boot 에서 jsp view 만들기 (feat freemarker)</title>
      <link href="/2018/02/22/spring-boot-jsp/"/>
      <url>/2018/02/22/spring-boot-jsp/</url>
      <content type="html"><![CDATA[<h3><span id="view를-추가해야한다">view를 추가해야한다.</span></h3><p>spring 을 사용하다가 spring boot 로 넘어오면서 front, back 을 나누어서 백단은 나름 Restful 하게 해서 api 콜만 처리하는 방식으로 변경하는 중이다.(front 는 react로 구성하는 중이다.) 그래서 spring boot 에서는 따로 view 처리해야할 일이 없었는데 기존에 spring 에서 view 처리를 해주는 요청을 가져와야 할일이 생겼다.<br>하지만 찾아보니 기존에 spring 에서 하던 방법으로는 안될 것 같다.<br>왜냐하면 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-jsp-limitations" rel="external nofollow noopener noreferrer" target="_blank">spring boot 에서는 jar 로 사용할 때는 jsp를 사용할 수 없다고 한다.</a><br>내용을 읽어보니 boot에 내장 tomcat에 하드코딩 패턴때문에 jar형식으로는 webapp내용을 가져올 수 없다고 한다. 그리고 공식적으로 jsp를 지원하지 않는다고 한다. boot에서 밀고 있는 template engine 들이 여러개 있었는데 간단한 view 하나 추가하는데 공수가 많이 들게되면 좋지 않을꺼라 생각해서 jsp로 view 를 구성하는 방법을 시도해보았다.<br>일단 작업을 시작하기 전에 현재 사용하고 있는 버전들을 정리하고 간다.</p><h3><span id="사용하고-있는-버전은-다음과-같다">사용하고 있는 버전은 다음과 같다.</span></h3><ul><li>spring boot 1.5.7</li><li>gradle 4.4</li></ul><h3><span id="나중에는-없어질-view-이지만">나중에는 없어질 view 이지만</span></h3><p>front작업이 react로 완료되면 이 view 는 더이상 필요하지 않다.<br>그래서 나는 최소한의 공수로 기존에 있는 jsp 파일을 사용하여 가볍게 포팅만 하고자 했다.</p><hr><h2><span id="1차-시도">1차 시도</span></h2><p>spring boot 에서 jsp view를 사용하기 위해 spring에서 구성하는 방법과 추가적으로 필요한 설정들을 해주었다.<br>spring boot 의 내장 tomcat에는 jsp parser가 없기 때문에 의존 패키지를 추가해주어야 한다.</p><ul><li>build.gradle</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">derendencies &#123;</span><br><span class="line">    compile(<span class="string">'javax.servlet:jstl'</span>)</span><br><span class="line">    compile(<span class="string">"org.apache.tomcat.embed:tomcat-embed-jasper"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 구조는 아래와 같이 구성했다. main밑에 webapp폴더를 추가해서 jsp파일을 추가해준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build.gradle</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── com</span><br><span class="line">    │   │       └── example</span><br><span class="line">    │   │           └── demo</span><br><span class="line">    │   │               ├── DemoApplication.java</span><br><span class="line">    │   │               └── MyController.java</span><br><span class="line">    │   ├── resources</span><br><span class="line">    │   │   └── application.properties</span><br><span class="line">    │   └── webapp</span><br><span class="line">    │       └── WEB-INF</span><br><span class="line">    │           └── jsp</span><br><span class="line">    │               └── index.jsp</span><br><span class="line">    └── <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>spring boot 는 webapp의 위치를 모르기 때문에 설정파일에 경로를 명시해주어야 한다.</p><ul><li>application.properties</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.view.prefix=/WEB-INF/jsp/</span><br><span class="line">spring.mvc.view.suffix=.jsp</span><br></pre></td></tr></table></figure><p>설정은 다했다. 이제 controller에서 view를 호출해보자.</p><ul><li>MyController.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModelAndView view = <span class="keyword">new</span> ModelAndView(<span class="string">"index"</span>);</span><br><span class="line">        view.addObject(<span class="string">"text"</span>, <span class="string">"world"</span>);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>설정파일에서 prefix, suffix를 적어주었기 때문에 view이름은 파일이름만 넣어주면 된다.</p><ul><li>index.jsp</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        hello $&#123;text&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이제 bootRun 을 하면 build 를 하고 테스트를 해볼 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew clean bootRun</span><br><span class="line">:compileJava </span><br><span class="line">:processResources </span><br><span class="line">:classes </span><br><span class="line">:findMainClass</span><br><span class="line">:bootRun</span><br></pre></td></tr></table></figure><ul><li>localhost:8080/</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello world</span><br><span class="line"></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>build 명령어로 jar파일을 만들어 보자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew clean build</span><br><span class="line">:compileJava </span><br><span class="line">:processResources </span><br><span class="line">:classes </span><br><span class="line">:findMainClass</span><br><span class="line">:jar</span><br><span class="line">:bootRepackage</span><br><span class="line">:assemble</span><br><span class="line">:compileTestJava </span><br><span class="line">:processTestResources NO-SOURCE</span><br><span class="line">:testClasses </span><br><span class="line">:<span class="built_in">test</span> </span><br><span class="line">:check </span><br><span class="line">:build</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 1.494 secs</span><br></pre></td></tr></table></figure><p><code>./build/libs/testGradle-0.0.1-SNAPSHOT.jar</code> 에 jar가 만들어졌다. 이걸로 직접 띄워서 호출해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar build/libs/testGradle-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>잘 뜨는 것을 확인 할 수 있다. 그런데 더이상 boot진영에서도 jsp파일을 그대로 쓰는걸 권장하고 있지 않으니 그냥 추천해주는 template engine로 넘어가야겠다는 생각이 들었다.</p><h2><span id="2차-시도">2차 시도</span></h2><p>찾아보니 정말 <a href="%22http://www.baeldung.com/spring-template-engines%22">여러가지 template engine</a>들이 있었다. 곰곰히 찾아보다 간단해 보이는 <a href="%22https://freemarker.apache.org/%22">Free Marker</a>를 써보기로 했다.<br>설정을 추가해주는 것도 간단하다. 추가를 해보자.</p><ul><li>build.gradle</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-freemarker'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 jsp로 인한 설정들을 모두 제거해준다.</p><ul><li>application.properties</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#spring.mvc.view.prefix=/WEB-INF/jsp/</span></span><br><span class="line"><span class="comment">#spring.mvc.view.suffix=.jsp</span></span><br></pre></td></tr></table></figure><p>그리고 free marker 의 확장자는 <code>.ftl</code> 이다. 기본적인 파일 위치는 <code>resources/templates/</code> 이다.<br>이에 따라 파일명을 수정해주고 이동까지 하면 아래와 같이 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build.gradle</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">│       ├── gradle-wrapper.jar</span><br><span class="line">│       └── gradle-wrapper.properties</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── com</span><br><span class="line">    │   │       └── example</span><br><span class="line">    │   │           └── demo</span><br><span class="line">    │   │               ├── DemoApplication.java</span><br><span class="line">    │   │               └── MyController.java</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       ├── application.properties</span><br><span class="line">    │       └── templates</span><br><span class="line">    │           └── index.ftl</span><br><span class="line">    └── <span class="built_in">test</span></span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── example</span><br><span class="line">                    └── demo</span><br><span class="line">                        └── DemoApplicationTests.java</span><br></pre></td></tr></table></figure><p>위와 같이 설정하고 빌드를 하고 jar파일을 띄워주면 1차시도와 동일한 결과가 나온다.<br>처음에는 jsp파일을 가지고 어떻게든 띄워보려고 노력했지만 다른 template engine을 보니 복잡한 jsp파일이 아니라면 굳이 사용하지 않아도 될거라는 생각이 들었다.</p><h2><span id="결론">결론</span></h2><p>아무래도 이제는 spring boot를 사용하면서 jsp를 사용하기는 어려울듯 싶다. 나도 결국에는 다른 template engine을 사용했는데 설정부터 적용이 너무 편해진 느낌.<br>각 template engine마다 문법이 조금 달라서 개인의 기호에 맞게 써야겠다만…(예전에 node를 할 때 <a href="%22https://www.npmjs.com/package/jade%22">jade</a>같은 경우엔 적잖은 충격을 받았었다.)<br>아무래도 아직까지는 html친화적인 문법이 조금은 더 익숙한 느낌이다.</p>]]></content>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> gradle </tag>
            
            <tag> jsp </tag>
            
            <tag> freemarker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django orm standalone feat(docker)</title>
      <link href="/2017/06/23/django-orm-standalone/"/>
      <url>/2017/06/23/django-orm-standalone/</url>
      <content type="html"><![CDATA[<p>필요에 의해서 배치 작업을 만들어야 했다.<br>간단하게 python으로 만들까 했는데, 단순 cursor로 사용하지 않고 django orm 으로 만들어 보고 싶은 생각이 들었다.<br>이미 작업하고 있는 django project 가 있었고, 그 안에서 사용하는 모델들을 사용해서 스크립트들을 만들면 좋겠다 생각이 들었다.<br>이미 django 구조에 익숙한 사람이라면 편하게 사용할 수 있을거라 생각했고, 관리가 용이하다는 장점이 있다.</p><h3><span id="해야할-일은">해야할 일은…</span></h3><ul><li>mysql, mongo에서 데이터를 주기적으로 가져온다.</li><li>데이터를 가공해서 다시 mysql이나 mongo로 데이터를 주기적으로 쌓아준다.</li><li>여러 서버의 상황에 맞게 대응을 해야한다.(real, sandbox, test등등)</li></ul><p>이미 사내에서 사용하고 있는 훌륭한 배치 스크립트 뭉치가 있다. 이 스크립트는 cursor를 통해서 mysql 데이터를 가져오고 넣는다.<br>물론 cursor로 쿼리를 작성해도 되지만 django-orm을 이용해서 이 작업을 조금 더 수월하게 할 수는 없을까? 하는 생각에 django template 를 사용하지 않고 orm 만 사용할 수 있는 프로젝트를 만들어보기로 했다.</p><h3><span id="django-orm-standalone으로-가자">django-orm standalone으로 가자</span></h3><p>일단 간단한 django 프로젝트를 하나만든다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> django-admin startproject django-orm</span></span><br></pre></td></tr></table></figure><p>설정과 최소한의 파일들을 제외하고 모두 제거해버리자. 구조는 아래와 같다.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── build.sh</span><br><span class="line">├── db</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── models.py</span><br><span class="line">├── manage.py</span><br><span class="line">├── requirements.txt</span><br><span class="line">├── run.sh</span><br><span class="line">├── scripts</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── test.py</span><br><span class="line">└── settings.py</span><br></pre></td></tr></table></figure><ol><li>requirements.txt : 스크립트를 수행할 떄 필요한 모듈등을 기술해준다.</li><li><a href="http://manage.py" rel="external nofollow noopener noreferrer" target="_blank">manage.py</a> : django-extension의 runscript 나 shell 기능을 사용할 수 있도록 한다.</li><li><a href="http://settings.py" rel="external nofollow noopener noreferrer" target="_blank">settings.py</a> : 여러 저장소의 접속 환경이나 환경변수들을 선언해준다.</li></ol><p>위의 구조를 뼈대로 필요한 부분을 채워서 사용하기로 한다. requirements.txt를 살펴보자.</p><ul><li>requirements.txt</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Django</span>==<span class="number">1.11</span>.<span class="number">2</span>    </span><br><span class="line"><span class="attr">django-extensions</span>==<span class="number">1.7</span>.<span class="number">9</span>  </span><br><span class="line"><span class="attr">mysqlclient</span>==<span class="number">1.3</span>.<span class="number">10</span>  </span><br><span class="line"><span class="attr">pytz</span>==<span class="number">2017.2</span>  </span><br><span class="line"><span class="attr">six</span>==<span class="number">1.10</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/django-extensions/django-extensions" rel="external nofollow noopener noreferrer" target="_blank">django-extension</a> 을 사용해서 스크립트들을 돌리고, mysql 의 데이터를 사용하기 위해 둘다 설치해주었다. 각자 필요한 부분이 있다면 추가해주면 된다.<br>이번에는 설정파일을 보도록 하자.</p><ul><li><a href="http://settings.py" rel="external nofollow noopener noreferrer" target="_blank">settings.py</a></li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"># Build paths inside the project like this: os.path.join(BASE_DIR, ...)</span><br><span class="line">BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line"></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test'</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="string">'3306'</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = (</span><br><span class="line">    <span class="string">'db'</span>,</span><br><span class="line">    <span class="string">'django_extensions'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># SECURITY WARNING: Modify this secret key <span class="keyword">if</span> using <span class="keyword">in</span> production!</span><br><span class="line">SECRET_KEY = <span class="string">'&#123;your_secret_key&#125;'</span></span><br><span class="line"></span><br><span class="line">LANGUAGE_CODE = <span class="string">'en-us'</span></span><br><span class="line"></span><br><span class="line">TIME_ZONE = <span class="string">'Asia/Seoul'</span></span><br><span class="line"></span><br><span class="line">USE_I18N = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">USE_L10N = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">USE_TZ = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>기본 설정파일에서 DATABASES 부분만 수정해 준 상태이고 model들이 KST로 시간을 붙어여 했기 때문에 타임존 설정을 서울로 바꾸어 주었다.<br>여기에서 로그에 대한 설정이나 다른 저장소에 대한 정보를 적어주면 된다.</p><p>구조를 잡았으니 추가해야할 패키지들을 설치해주도록 한다. 여기서부터는 익히 알고 있는 패턴이므로 간단하게 살펴보자.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install -r requiremwnts.txt</span></span><br></pre></td></tr></table></figure><p>모델은 현재 자신의 db에 있는 테이블을 정의해주고 orm으로 붙기만 하면 된다. 모델을 한번 보자.</p><ul><li><a href="http://model.py" rel="external nofollow noopener noreferrer" target="_blank">model.py</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    id = models.IntegerField(primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        managed = <span class="keyword">False</span></span><br><span class="line">        db_table = <span class="string">'user'</span></span><br></pre></td></tr></table></figure><p>db 설정을 해주었고 필요한 패키지를 설치했고, 모델들을 정의해주었다면 한번 붙어보자.</p><h3><span id="hello-orm">hello orm</span></h3><p>python shell 로 들어가서 모델을 통해 데이터를 가져오면 된다.</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> manage.<span class="keyword">py</span> <span class="keyword">shell</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">from</span> db.models import User</span><br><span class="line">&gt;&gt;&gt; User.objects.all()</span><br><span class="line">&lt;QuerySet [&lt;User:<span class="built_in"> User </span>object&gt;, &lt;User:<span class="built_in"> User </span>object&gt;, &lt;User:<span class="built_in"> User </span>object&gt;, &lt;User:<span class="built_in"> User </span>object&gt;, &lt;User:<span class="built_in"> User </span>object&gt;]&gt;</span><br></pre></td></tr></table></figure><p>모델을 통해 데이터를 가져올 수 있고, 작업해야할 부분은 스크립트를 만들어서 사용하도록 한다. 기본적인 스크립트를 하나 만들어보자.</p><ul><li><a href="http://test.py" rel="external nofollow noopener noreferrer" target="_blank">test.py</a></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> db.models import <span class="keyword">User</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="keyword">run</span><span class="bash">(*script_args):</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">user_list = User.objects.all()</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="keyword">for</span> user <span class="keyword">in</span> user_list:</span></span><br><span class="line"><span class="bash"><span class="built_in">print</span>(<span class="string">'name : '</span>, user.name)</span></span><br></pre></td></tr></table></figure><p>간단하다. 스크립트를 만들었으니 수행해보자. runscript 는 위에서도 언급했지만 django-extension의 기능중 하나이다.</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py runscript test</span><br><span class="line">name :  <span class="type">teddy</span></span><br><span class="line">name :  <span class="type">canel</span></span><br><span class="line">name :  <span class="type">twght</span></span><br></pre></td></tr></table></figure><p>이제 필요한 스크립트를 만들어서 crontab에 걸어두면 django orm 을 이용해서 스크립트를 사용할 수 있다.<br>여기까지 했으면 간단하게 끝날텐데, 이 배치 스크립트를 여러 환경에 배포하고 돌려야 하는 일이 남아있었다.<br>물론 서버가 많지 않아 git으로 땡기거나 손으로 직접 옮겨도 되지만, 칼을 뽑은 김에 docker image 로 만들어서 써보자. 어렵지 않다.</p><p>Docker iamge 로 만드는 작업은 완전 단순하다. 사용법도 전혀 어렵지 않다. 일단 Dockerfile을 보자.</p><ul><li>Dockerfile</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.5</span>-<span class="keyword">onbuild</span></span><br></pre></td></tr></table></figure><p>사족으로 <a href="https://github.com/docker-library/python/blob/9a9021f2134d953165b31d98cacb95aa34076f90/3.5/onbuild/Dockerfile" rel="external nofollow noopener noreferrer" target="_blank">pythpn:3.5-onbuild</a> 에서 하는 일은 아래와 같다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> THIS DOCKERFILE IS GENERATED VIA "update.sh"</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># PLEASE DO NOT EDIT IT DIRECTLY.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/app</span></span><br><span class="line"><span class="bash">WORKDIR /usr/src/app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ONBUILD COPY requirements.txt /usr/src/app/</span></span><br><span class="line"><span class="bash">ONBUILD RUN pip install --no-cache-dir -r requirements.txt</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ONBUILD COPY . /usr/src/app</span></span><br></pre></td></tr></table></figure><p>이렇게만 써주고 build 하면 끝이다.</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --<span class="keyword">tag</span> <span class="title">django-orm</span>:<span class="number">0.1</span> .</span><br></pre></td></tr></table></figure><p>이미지를 만들었다면 다음과 같이 생성이 된다.</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY            <span class="keyword">TAG</span>                 <span class="title">IMAGE</span> ID            CREATED             SIZE</span><br><span class="line">django-orm            <span class="number">0.1</span>                 c8a6c10c8233        About an hour ago   <span class="number">715</span> MB</span><br></pre></td></tr></table></figure><p>이 이미지를 사용하기 위해서는 run 명령으로 사용하도록 하자.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> --name django-orm django-orm python manage.py runscript <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><h3><span id="docker로-사용할-때-신경써야할-부분이-있다면">docker로 사용할 때 신경써야할 부분이 있다면</span></h3><p>container 내부에서는 host에 바로 접근할 수가 없기 때문에 mysql localhost 를 바라봐야 한다면 localhost 로 명시해주면 안된다.<br>물론 회피 방법은 조금만 구글링해도 나오지만 원칙적으로는 접근을 할 수 없으므로 이 부분을 신경써서 작업해주어야 한다.<br><s>나는 mysql이 다른 서버에 동작하고 있었기 떄문에 별 문제는 없었다.</s></p><h3><span id="결론">결론</span></h3><p>이미 django project 를 구동해본 경험이 있다면 큰 어려움 없이 사용할 수 있을 것이다.<br>물론 해당 프로젝트에서 배치 스크립트를 작성할 수도 있지만, 성격이 맞지 않을 수 있기 때문에 굳이 억지로 넣을 필요는 없다.<br>cursor로 작업하는게 간단하고 편할 수도 있지만, 여러 패키지를 함께 써야하고 여러 db 설정을 바라봐야 한다면 django 의 골격을 그대로 사용하는 방법이 손쉬울 수 있겠다.<br>해당 예제는 <a href="https://github.com/nevercaution/django-orm" rel="external nofollow noopener noreferrer" target="_blank">django-orm standalone</a> 에서 확인할 수 있다.</p>]]></content>
      
      
        <tags>
            
            <tag> django </tag>
            
            <tag> python </tag>
            
            <tag> orm </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django에서 SSO하기</title>
      <link href="/2016/05/06/django-sso/"/>
      <url>/2016/05/06/django-sso/</url>
      <content type="html"><![CDATA[<p>회사에서 필요에 의해 <a href="https://ko.wikipedia.org/wiki/%ED%86%B5%ED%95%A9_%EC%9D%B8%EC%A6%9D," title="Single Sign On" rel="external nofollow noopener noreferrer" target="_blank">Single Sign On</a>을 구현해야 할 일이 있었다. 3개의 독립된 사이트가 있었고, 각자 로그인을 따로 해야 한다는 점이 사용자 입장에서는 번거로운 일이 될 수 있다는 이유에서 였다.</p><p>3개의 사이트는 하나의 유저테이블을 바라보고 있었기 때문에 충분히 합당한 이유였다. 하지만 django에서 제공하는 기본 유저 테이블을 사용하지 않기 때문에 찾아봤었던 다른 인증 툴들은 그대로 사용하기 까다로워 보였다. 내가 구현해야 하는 상황에는 몇가지 제약사항이 있었다.</p><ol><li><p>로그인을 시도할 때 기존에 제공되는 auth_user 테이블이 아닌 <u>별도의 user 테이블을 사용하고 있다.</u></p></li><li><p>기존에 제공되는 user 모델을 사용하지 않기 때문에 <u>reatframework 에서 기존에 제공하는 인증방식을 그대로 사용할 수 없었다.</u></p></li><li><p>이미 테이블이 존재하고 <u>django 프로젝트에서 migration 을 할 수 없는 상황이다.</u> 기존에 생성되어 있는 테이블들의 구성을 변경할 수는 있지만 그 과정과 절차가 까다롭고 (회사의 사정에 의해), 외래키를 사용하지 않았기 때문에 모델과 테이블간의 100% 싱크가 맞지 않는 상황이었다.</p></li><li><p>위와 같은 이유로 찾아봤었던 <a href="https://github.com/jbittel/django-mama-cas," title="MamaCas" rel="external nofollow noopener noreferrer" target="_blank">MamaCAS</a> 같은 외부 인증툴을 사용할 수 없었다. (migration을 할 수 없었기에 인증을 위해 별도의 테이블을 생성하기 까다로운 상황이었다.)</p></li></ol><p>3개의 프로젝트들이 출시가 얼마 남지 않은 상황이고, 인증을 위해서 별도의 커다란 작업이 있는 것은 별로 좋은 선택이 아니였다. 물론 외부의 다른 툴들을 이용할 수도 있었지만, 단순 인증을 위해 외부툴을 사용하기엔 부담스러운 부분이 있었고, 볼륨을 크게 잡고 싶지 않았다.</p><p>여러 방법을 찾아보면서 몇가지 아이디어가 나왔었다.</p><ol><li><p><a href="https://redis.io/," title="redis" rel="external nofollow noopener noreferrer" target="_blank">redis</a> 를 이용해서 인증 정보를 저장하는 방식</p></li><li><p><a href="https://jwt.io/," title="jwt" rel="external nofollow noopener noreferrer" target="_blank">jwt</a>를 이용해서 javascript 내부에서 localStorage 에 인증 정보를 저장하는 방식</p></li><li><p>cookie에 저장하는 방식</p></li></ol><p>나는 일단 1번의 redis는 제외하기로 했다. 이미 각각의 프로젝트에서 redis를 사용하고 있었고, 인증을 위해 별도의 redis를 띄우는게 번거롭다고 생각했다. 그리고 2번의 localStorage 방식은 javascript에서 ajax통신을 각 페이지별로 날려 유효한 인증을 판단하는 방식이었는데, django 단에서 각 request마다 헤더에 인증 정보를 넣기가 까다로웠다. (하지만 jwt로 토큰을 암호화 하는건 괜찮은 방법이라 생각했다.) 3번의 cookie 방식은 별도의 작업 없이 구현이 가능했지만 3개의 사이트가 같은 메인 도메인 하에 있어야 가능했었다. 어차피 모든 사이트가 회사 내부에서 사용할 목적으로 만들어 지고 있는 프로젝트 였고 같은 메인 도메인만 사용하면 되었기 때문에 나는 3번째의 방법을 사용하기로 했다.</p><p>서론이 길었지만… 그리하여 jwt와 cookie를 이용해서 sso를 구현해 보기로 했다.</p><p>여러 사이트가 있고 각각 로그인(유저 인증)이 필요하고 기능 마다 해당 유저가 접근할 수 있는(허가) 기능이 필요하다.</p><p>(single sign on 을 하다보니 authentication 과 permission 처리가 필요했다…)</p><p>여러 개의 사이트가 공유하는 유저 정보가 있고, 이 정보로 로그인을 하기 때문에 모든 사이트에서 한번의 로그인을 하면 되는 기능이 필요했다.추가적으로 각 사이트 별로는 각자의 허가 정보가 있으므로 이 정보는 공유하지 않고 각자 구현한다. (템플릿만 제공)</p><p>한마디로 요약하면 쿠키에 암호화된 토큰 정보를 도메인이 같은 사이트들끼리 로그인 정보를 공유를 해서 사용하는 방법이다.</p><h2><span id="예상-시나리오">예상 시나리오</span></h2><p><a href="http://alpha.mysite.com" rel="external nofollow noopener noreferrer" target="_blank">alpha.mysite.com</a>, <a href="http://beta.mysite.com" rel="external nofollow noopener noreferrer" target="_blank">beta.mysite.com</a>, <a href="http://charlie.mysite.com" rel="external nofollow noopener noreferrer" target="_blank">charlie.mysite.com</a> 3개의 사이트가 있다.<br>beta 에서 로그인을 하고 charlie 사이트에 접속할 경우 이미 로그인이 되어 있다.<br>3개의 사이트는 각자 permission 이 따로 존재한다.<br>alpha 에서 로그아웃을 할 경우, 나머지 사이트에서도 모두 로그아웃이 된다.<br>로그인 정보가 만료되었을 경우에도 로그아웃 처리된다.</p><h2><span id="시나리오-순서-별-설명">시나리오 순서 별 설명</span></h2><ol><li>로그인 시 : <u>jwt token</u> 을 발급해서 request cookie에 저장한다. (이 때, <u>cookie</u> 의 domain은 main domain 값을 넣어준다.&lt;<a href="http://mysite.com" rel="external nofollow noopener noreferrer" target="_blank">mysite.com</a>&gt;)</li><li>인증이 필요한 페이지에 접속할 경우<br>rest framework 의 <u>authentication</u> class 에서 cookie 에 저장되어 있는 token 값의 유효성을 검사한다.<br>rest framework 의 <u>permission</u> class 에서 해당 유저가 기능에 접근 허가 여부를 판단한다.</li><li>로그아웃 시 : cookie 의 token 값을 지워준다.</li><li>추가 정보<ul><li>인증에 실패한 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.</li><li>기능 접근 허가가 거부된 경우 : block page 를 표시한다.</li><li>토큰이 만료된 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.</li></ul></li><li>제약사항<ul><li>메인 도메인이 동일해야한다.</li><li>permission 정보는 공유하지 않기 때문에 각자 사이트에서 구현해야 한다.</li></ul></li></ol><h2><span id="환경-설정">환경 설정</span></h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">python</span> 3<span class="selector-class">.4</span><span class="selector-class">.3</span></span><br><span class="line"><span class="selector-tag">django</span> 1<span class="selector-class">.8</span><span class="selector-class">.4</span></span><br><span class="line"><span class="selector-tag">djangorestframework</span> 3<span class="selector-class">.3</span><span class="selector-class">.0</span></span><br></pre></td></tr></table></figure><p>하나씩 시작해보자.</p><h3><span id="패키지-추가하기">패키지 추가하기</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install djangorestframework-jwt</span></span><br></pre></td></tr></table></figure><h3><span id="로그인-하기">로그인 하기</span></h3><h4><span id="토큰-생성하기">토큰 생성하기</span></h4><p>유저 정보가 맞을 경우 이 정보를 토대로 jwt token을 생성해준다.<br>jwt_util.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> calendar <span class="keyword">import</span> timegm</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.settings <span class="keyword">import</span> api_settings</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> user.models.CustomUser <span class="keyword">import</span> CustomUser</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obtain_token</span><span class="params">(user: CustomUser)</span>:</span></span><br><span class="line">    jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">    jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"> </span><br><span class="line">    payload = jwt_payload_handler(user)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Include original issued at time for a brand new token,</span></span><br><span class="line">    <span class="comment"># to allow token refresh</span></span><br><span class="line">    <span class="keyword">if</span> api_settings.JWT_ALLOW_REFRESH:</span><br><span class="line">        payload[<span class="string">'orig_iat'</span>] = timegm(</span><br><span class="line">            datetime.utcnow().utctimetuple()</span><br><span class="line">        )</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> jwt_encode_handler(payload)</span><br></pre></td></tr></table></figure><p>jwt 변수들에 대한 자세한 설정은 Rest Framework JWT 에서 확인 할 수 있다. 그리고 default 로 설정된 변수들을 재선언 하고 싶다면 setting 에 해주면 된다.</p><p><a href="http://settings.py" rel="external nofollow noopener noreferrer" target="_blank">settings.py</a></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JWT_AUTH = &#123;</span><br><span class="line">    <span class="string">'JWT_EXPIRATION_DELTA'</span>: datetime.timedelta<span class="comment">(hours=24)</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="쿠키에-저장하기">쿠키에 저장하기</span></h4><p>사용자가 입력한 아이디와 암호가 맞을 경우 이 정보를 cookie 에 저장을 한다. 저장할 때 domain option 을 main domain(<a href="http://mysite.com" rel="external nofollow noopener noreferrer" target="_blank">mysite.com</a>) 로 설정해준다. domain 설정을 해주지 않을 경우 다른 사이트에서 쿠키정보를 공유할 수 없다.</p><p><a href="http://view.py" rel="external nofollow noopener noreferrer" target="_blank">view.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginView</span><span class="params">(View)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> TemplateResponse(request, <span class="string">'account/login.html'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        username = request.POST.get(<span class="string">'username'</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">'password'</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            admin = CustomUser.objects.get(username=username)</span><br><span class="line">            <span class="comment"># 유저 암호 검사하기.</span></span><br><span class="line">            <span class="keyword">if</span> security.matches_password(password, admin.password):</span><br><span class="line">                <span class="comment"># obtain jwt token</span></span><br><span class="line">                token = obtain_token(admin)</span><br><span class="line"> </span><br><span class="line">                <span class="comment"># set cookie</span></span><br><span class="line">                response = HttpResponseRedirect(reverse(<span class="string">'root'</span>))</span><br><span class="line">                response.set_cookie(key=<span class="string">'token'</span>, value=token, domain=settings.COOKIE_DOMAIN)</span><br><span class="line">                <span class="keyword">return</span> response</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                context = &#123;</span><br><span class="line">                    <span class="string">'error'</span>: <span class="string">'비밀번호가 일치하지 않습니다.'</span></span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">except</span> TAdmin.DoesNotExist:</span><br><span class="line">            context = &#123;</span><br><span class="line">                <span class="string">'error'</span>: <span class="string">'존재하지 않는 ID입니다.'</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> TemplateResponse(request, <span class="string">'account/login.html'</span>, context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>공통으로 사용할 메인 도메인 이름은 각 사이트 마다 통일 해줘야 한다.</p><p><a href="http://settings.py" rel="external nofollow noopener noreferrer" target="_blank">settings.py</a></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">COOKIE_DOMAIN</span> = <span class="string">'mysite.com'</span></span><br></pre></td></tr></table></figure><p>쿠키에 토큰 값을 저장 했으므로 이제 각 사이트에 로그인 되었다고 할 수 있는 첫번 째 단계는 달성했다.</p><h4><span id="페이지-인증정보-확인하기">페이지 인증정보 확인하기</span></h4><p>로그인이 되어 있어야 접근할 수 있는 페이지의 경우 로그인 정보를 확인한 후에 정보를 로드한다. RestFramework 에서 제공하는 APIView 를 사용해서 인증 정보를 확인한다.</p><p><a href="http://view.py" rel="external nofollow noopener noreferrer" target="_blank">view.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    authentication_classes = (CustomAuthentication, )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        redirect_url = <span class="string">"/home"</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponseRedirect(redirect_url)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 authentication class 를 명시적으로 선언해주었는데, 모든 APIView(인증과 허가가 필요한 페이지의 경우) 에 적용될 수 있도록 settings 에 선언해줄 수 있다.</p><p>(인증 실패나 허가 요청 실패시 처리해줄 수 있는 핸들러도 미리 추가해놓자.)</p><p><a href="http://settings.py" rel="external nofollow noopener noreferrer" target="_blank">settings.py</a></p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    '<span class="attribute">DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class="line">        'common<span class="variable">.utils</span><span class="variable">.authentication</span><span class="variable">.CustomAuthentication</span>',</span><br><span class="line">    ),</span><br><span class="line">    'EXCEPTION_HANDLER': 'common<span class="variable">.utils</span><span class="variable">.custom_exception_handler</span><span class="variable">.custom_exception_handler</span>'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>인증 확인은 쿠키에 저장되어 있는 토큰 정보로 확인한다. 토큰으로 정상적인 유저를 가져올 수 있다면 유효한 유저라고 판단한다.</p><p><a href="http://authentication.py" rel="external nofollow noopener noreferrer" target="_blank">authentication.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> authentication</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> common.utils.jwt_util <span class="keyword">import</span> obtain_user</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomAuthentication</span><span class="params">(authentication.BaseAuthentication)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        쿠키에 저장되어 있는 token 값으로 유저를 가져옵니다. 가져오는 상황에서 예외가 발생할 수 있으며 정상적으로 가져온 경우에는 인증된 유저라고 판단합니다.</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        token = request.COOKIES.get(<span class="string">'token'</span>, <span class="keyword">None</span>)</span><br><span class="line">        user = obtain_user(token)</span><br><span class="line">        <span class="keyword">return</span> (user, <span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>쿠키에 저장되어 있는 토큰을 decode 하여 유효한 정보인지를 판단한다.</p><p>jwt_util.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obtain_user</span><span class="params">(token: str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    payload = &#123;'username': 'adm001', 'email': 'test@mysite.com', 'user_id': 1, 'exp': 1462187582&#125;</span></span><br><span class="line"><span class="string">    :param token:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    jwt_decode_handler = api_settings.JWT_DECODE_HANDLER</span><br><span class="line">    jwt_get_username_from_payload = api_settings.JWT_PAYLOAD_GET_USERNAME_HANDLER</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> token <span class="keyword">or</span> len(token) == <span class="number">0</span>:  <span class="comment"># case1: 토큰을 분실 했을 경우</span></span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">'Invalid token header. Non credentials provided.'</span>)</span><br><span class="line">        <span class="comment"># raise exceptions.AuthenticationFailed(&#123;'error': 'Invalid token header. No credentials provided.'&#125;)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        payload = jwt_decode_handler(token)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">except</span> jwt.ExpiredSignature:  <span class="comment"># case2: 토큰이 만료되었을 경우</span></span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">'Signature has expired.'</span>)</span><br><span class="line">        <span class="comment"># raise exceptions.AuthenticationFailed(&#123;'error': 'Signature has expired.'&#125;)</span></span><br><span class="line">    <span class="keyword">except</span> jwt.DecodeError:  <span class="comment"># case3: 디코드 실패</span></span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">'Error decoding signature.'</span>)</span><br><span class="line">        <span class="comment"># raise exceptions.AuthenticationFailed(&#123;'error': 'Error decoding signature.'&#125;)</span></span><br><span class="line"> </span><br><span class="line">    username = jwt_get_username_from_payload(payload)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username:  <span class="comment"># case4: payload 가 잘못되어 username을 가져올 수 없는 경우</span></span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">'Invalid payload.'</span>)</span><br><span class="line">        <span class="comment"># raise exceptions.AuthenticationFailed(&#123;'error': 'Invalid payload.'&#125;)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        user = CustomUser.objects.get(username=username)</span><br><span class="line">    <span class="keyword">except</span> CustomUser.DoesNotExist:  <span class="comment"># case5: 해당 유저가 존재하지 않는 경우</span></span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">"User doesn't exists."</span>)</span><br><span class="line">        <span class="comment"># raise exceptions.AuthenticationFailed(&#123;'error': "User doesn't exists."&#125;)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure><p>여러 이유로 인증에 실패할 경우엔 인증 실패 예외가 발생하게 되는데 이는 따로 핸들러로 처리해주어야 한다. (에러 정보는 response.data 에 담겨온다.)<br>(여기서는 인증 실패 예외가 발생할 경우 쿠키에 저장되어 있는 토큰값을 지워버리고 로그인 페이지로 보내버린다.)</p><p>custom_exception_handler.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.core.urlresolvers <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_exception_handler</span><span class="params">(exc, context)</span>:</span></span><br><span class="line">    <span class="comment"># 발생한 exception을 가져온다.</span></span><br><span class="line">    response = exception_handler(exc, context)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="comment"># response_data = response.data['detail']</span></span><br><span class="line">        <span class="comment"># print('response : ', response.__dict__)</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 예외가 발생할 경우엔 token쿠키를 지워준다</span></span><br><span class="line">        response.delete_cookie(<span class="string">'token'</span>, domain=settings.COOKIE_DOMAIN)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'login'</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h4><span id="페이지-접근-허가-정보-확인하기">페이지 접근 허가 정보 확인하기</span></h4><p>접근하고자 하는 페이지가 각 유저별로 인증 정보가 필요하다면 유저의 인증 정보를 확인할 수 있어야 한다.</p><p><a href="http://permission.py" rel="external nofollow noopener noreferrer" target="_blank">permission.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> BasePermission</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPermission</span><span class="params">(BasePermission)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> do something</span></span><br><span class="line">        print(<span class="string">'CustomPermission user : '</span>, request.user)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>(현재는 어떤 허가 정보도 판단하지 않지만 이 부분에서 유저 정보를 가지고 해당 페이지에 대한 허가 정보를 판단해서 boolean 값으로 반환해준다. True일 경우 허가된 경우고 False일 경우엔 허가되지 않는 유저이다.)</p><p>APIView 에서 허가 정보도 명시적으로 선언해서 확인할 수 있다.</p><p><a href="http://view.py" rel="external nofollow noopener noreferrer" target="_blank">view.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    authentication_classes = (CustomAuthentication, )</span><br><span class="line">    permission_classes = (CustomPermission, )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        redirect_url = <span class="string">"/home"</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponseRedirect(redirect_url)</span><br></pre></td></tr></table></figure><p>마찬가지로 모든 APIView 에서 허가 정보를 확인해야 한다면 settings 에 설정해줄 수 있다. 좀 전에 인증 정보를 작성한 부분에 추가해주자.</p><p><a href="http://settings.py" rel="external nofollow noopener noreferrer" target="_blank">settings.py</a></p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    '<span class="attribute">DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class="line">        'common<span class="variable">.utils</span><span class="variable">.authentication</span><span class="variable">.CustomAuthentication</span>',</span><br><span class="line">    ),</span><br><span class="line">    'DEFAULT_PERMISSION_CLASSES': (</span><br><span class="line">        'common<span class="variable">.utils</span><span class="variable">.permission</span><span class="variable">.CustomPermission</span>',</span><br><span class="line">    ),</span><br><span class="line">    'EXCEPTION_HANDLER': 'common<span class="variable">.utils</span><span class="variable">.custom_exception_handler</span><span class="variable">.custom_exception_handler</span>'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>허가 요청에 대한 부분이 추가되었으므로 예외 처리 핸들러에서 이 부분에 대한 처리도 추가해줘야 한다. 요청이 실패할 경우 403 에러가 발생하는데 이 부분에 대한 처리를 해준다.</p><p>custom_exception_handler.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.core.urlresolvers <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_exception_handler</span><span class="params">(exc, context)</span>:</span></span><br><span class="line">    <span class="comment"># 발생한 exception을 가져온다.</span></span><br><span class="line">    response = exception_handler(exc, context)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="comment"># response_data = response.data['detail']</span></span><br><span class="line">        <span class="comment"># print('response : ', response.__dict__)</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># permission 이 안되는 경우엔 block page 로 넘겨준다.</span></span><br><span class="line">        <span class="keyword">if</span> response.status_code == status.HTTP_403_FORBIDDEN:</span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'block'</span>))</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 예외가 발생할 경우엔 token쿠키를 지워준다</span></span><br><span class="line">        response.delete_cookie(<span class="string">'token'</span>, domain=settings.COOKIE_DOMAIN)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'login'</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p>인증 실패인 경우에는 쿠키에서 토큰 정보를 삭제하고<br>로그인 페이지로 보내버리고,<br>허가 요청 거부일 경우에는 block 페이지로 보내버렸는데,<br>이 부분은 각 사이트의 상황에 맞게 처리해주면 된다.</p><h4><span id="로그아웃-하기">로그아웃 하기</span></h4><p>로그아웃은 간단하다. 단지 쿠키에 저장되어 있는 토큰 값을 지워버리면 되기 때문이다.</p><p><a href="http://view.py" rel="external nofollow noopener noreferrer" target="_blank">view.py</a></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogoutView</span>(<span class="title">View</span>):</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(<span class="keyword">self</span>, request)</span></span><span class="symbol">:</span></span><br><span class="line">        response = HttpResponseRedirect(reverse(<span class="string">'login'</span>))</span><br><span class="line">        response.delete_cookie(<span class="string">'token'</span>, domain=settings.COOKIE_DOMAIN)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h4><span id="요약">요약</span></h4><p>지금까지 추가된 파일들과 클래스를 정리하자면 다음과 같다.</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">common/utils/custom_exception_handler.py</span><br><span class="line">    -<span class="ruby"> custom_exception_handler</span></span><br><span class="line"><span class="ruby">common/utils/authentication.py</span></span><br><span class="line"><span class="ruby">    - CustomAuthentication</span></span><br><span class="line"><span class="ruby">common/utils/permission.py</span></span><br><span class="line"><span class="ruby">    - CustomerPermission</span></span><br><span class="line"><span class="ruby">common/utils/jwt_util.py</span></span><br><span class="line"><span class="ruby">    - obtain_token</span></span><br><span class="line"><span class="ruby">    - obtain_user</span></span><br></pre></td></tr></table></figure><p>여기까지 따라왔다면 sso를 완성 할 수 있다. 하나의 사이트에서 동작하는지 여부를 검사하고 싶다면 hosts 에 도메인을 추가해서 테스트 해보자.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/hosts</span></span><br></pre></td></tr></table></figure><p>/etc/hosts</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span>   <span class="selector-tag">alpha</span><span class="selector-class">.mysite</span><span class="selector-class">.com</span></span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span>   <span class="selector-tag">beta</span><span class="selector-class">.mysite</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure><p>위와 같이 추가하고 테스트를 해볼 수 있다.</p><h2><span id="결론">결론</span></h2><p>유저의 로그인 검증 후 유저 정보를 jwt 를 이용해서 토큰을 생성한 후, 이 정보는 메인 도메인으로 쿠키에 저장을 한다. 인증이 필요한 페이지의 경우 cookie 에 저장되어 있는 토큰으로 인증된 유저인지 여부를 판단한다. 이 때, 이 토큰 값이 유효하지 않을 경우엔 강제로 로그아웃 처리를 한다. jwt 토큰의 만료 시간을 주어 일정 시간이 지나면 로그인이 풀리도록 했다. 메인 도메인 하위의 3개의 사이트중 하나의 사이트에서만 로그인을 하면 나머지 두개의 사이트에서도 로그인이 되어 있다(같은 쿠키의 토큰을 사용하기 때문)</p><h3><span id="추신">추신</span></h3><p>나름 간단하게 기능을 구현하고자 했는데 로그인 정보를 저장하고 그 토큰을 처리하기 위해 여러 처리가 붙었다. 그리고 토큰 값을 만들고 검증하고 이를 인증하는 코드들을 직접 쓰다보니 조금은 번거로운 작업들이 포함되어 있는 건 사실이다… 때로는 오픈소스를 별다른 이해 없이 기능을 사용하기 위해 가져다 쓰는 것 보다 내부 로직을 이해하고 내가 필요한 부분들만 가져다 쓰는 작업을 하면 재미있기도 하고 후에 문제가 생기거나 기능 변경이 생겼을 때 대처가 빠르다. 물론 이런 방식이 정답을 아닐지는 몰라도 덕분에 재미있는 작업을 했다는 점에 만족한다.</p>]]></content>
      
      
        <tags>
            
            <tag> django </tag>
            
            <tag> sso </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django에서 ajax요청하기</title>
      <link href="/2016/03/27/django-ajax/"/>
      <url>/2016/03/27/django-ajax/</url>
      <content type="html"><![CDATA[<p>View에서 get, post요청을 할 때 template단에서 ajax요청을 날려야할 때가 있다.<br>APIVIew, View 두개의 경우를 살펴보자.<br>1.APIView ↔ ajax (post, get)<br>(post의 케이스로 설명을 하였지만 get도 동일한 방식이다.)<br>가장 빈번하게 사용하는 케이스이다. template 에서 버튼을 눌러 요청을 ajax로 날려 결과값을 받아와서 전체 화면을 다시 그리지 않고 필요한 부분만 갱신해줄 수 있다.</p><ul><li>template.html</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"&#123;% url 'request:url' %&#125;"</span>,</span><br><span class="line">    <span class="built_in">type</span>: <span class="string">'POST'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        <span class="string">'user_id'</span>: user_id</span><br><span class="line">    &#125;,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> <span class="params">(response)</span></span> &#123;</span><br><span class="line">        // TODO: <span class="keyword">do</span> something.</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">error</span>: <span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><a href="http://url.py" rel="external nofollow noopener noreferrer" target="_blank">url.py</a></li></ul> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^request/url$'</span>, views.TestView.as_view(), name=<span class="string">'url'</span>),</span><br></pre></td></tr></table></figure><ul><li><a href="http://view.py" rel="external nofollow noopener noreferrer" target="_blank">view.py</a></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>(<span class="title">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(<span class="keyword">self</span>, request)</span></span><span class="symbol">:</span></span><br><span class="line">        user_id = request.POST.get(<span class="string">'user_id'</span>)</span><br><span class="line">      <span class="comment"># do something</span></span><br><span class="line">       <span class="keyword">return</span> Response()</span><br></pre></td></tr></table></figure><p>View class를 상속받고 post 메소드로 받는다면 ajax 요청시 csrf 토큰이 없다고 하면서 403에러가 발생한다.<br>이를 해결해주기 위해 APIView를 상속받아서 처리하면 csrf 인증을 피해갈 수 있다.  (피해간다기보단 이미 인증이 되어있는 요청이라고 판단하는 것이지만)<br>이는 APIView의 as_view() 메소드를 보면 알 수 있는데</p><ul><li>api_view.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">as_view</span><span class="params">(cls, **initkwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Store the original class on the view function.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    This allows us to discover information about the view when we do URL</span></span><br><span class="line"><span class="string">    reverse lookups.  Used for breadcrumb generation.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(getattr(cls, <span class="string">'queryset'</span>, <span class="keyword">None</span>), models.query.QuerySet):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">force_evaluation</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">'Do not evaluate the `.queryset` attribute directly, '</span></span><br><span class="line">                <span class="string">'as the result will be cached and reused between requests. '</span></span><br><span class="line">                <span class="string">'Use `.all()` or call `.get_queryset()` instead.'</span></span><br><span class="line">            )</span><br><span class="line">        cls.queryset._fetch_all = force_evaluation</span><br><span class="line">        cls.queryset._result_iter = force_evaluation  <span class="comment"># Django &lt;= 1.5</span></span><br><span class="line"> </span><br><span class="line">    view = super(APIView, cls).as_view(**initkwargs)</span><br><span class="line">    view.cls = cls</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># <span class="doctag">Note:</span> session based authentication is explicitly CSRF validated,</span></span><br><span class="line">    <span class="comment"># all other authentication is CSRF exempt.</span></span><br><span class="line">    <span class="keyword">return</span> csrf_exempt(view)</span><br></pre></td></tr></table></figure><p>마지막 라인에 csrf_exempt로 view를 감싸준다. 이는 해당 API요청이 csrf 인증이 되어있다고 명시해주는 것이다.<br>그리고, 내부로 파고 들어가면  APIView에서 authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 로 설정이 되어있는데, restframework의 setting을 살펴보면 아래와 같이 정의가 되어있음을 알 수 있다.</p><ul><li>api_settings.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class="line">    <span class="string">'rest_framework.authentication.SessionAuthentication'</span>,</span><br><span class="line">    <span class="string">'rest_framework.authentication.BasicAuthentication'</span></span><br><span class="line">),</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Authentication</span></span><br><span class="line"><span class="string">'UNAUTHENTICATED_USER'</span>: <span class="string">'django.contrib.auth.models.AnonymousUser'</span>,</span><br><span class="line"><span class="string">'UNAUTHENTICATED_TOKEN'</span>: <span class="keyword">None</span>,</span><br></pre></td></tr></table></figure><p>인증 처리를 rest_framework의 SessionAuthentication으로 하겠다는 내용과 인증 유저를 AnonymousUser 로 설정을 해준다.<br>기존의 인증절차에서 default인증 객체를 검사하게 되는데, 이 때 user객체의 active를 검사할 때 이 객체가 유효하지 않으면 unauthenticated_user로 AnonymousUser객체를 생성하게 된다. 접근 허용 체크를 할 때는 APIView에 정의된 permission class로 체크를 하는데 아래와 같다.</p><ul><li>api_settings.py</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">'DEFAULT_PERMISSION_CLASSES': (</span><br><span class="line">    'rest_framework.permissions.AllowAny',</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>AllowAny Class는 permission요청에 대해 무조건 True를 반환해주므로, APIView의 check_permissions 메소드에서 권한 체크를 할 때 권한이 있다고 판단을 한다.</p><ul><li><a href="http://permissions.py" rel="external nofollow noopener noreferrer" target="_blank">permissions.py</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllowAny</span><span class="params">(BasePermission)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Allow any access.</span></span><br><span class="line"><span class="string">    This isn't strictly required, since you could use an empty</span></span><br><span class="line"><span class="string">    permission_classes list, but it's useful because it makes the intention</span></span><br><span class="line"><span class="string">    more explicit.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>즉, APIView는 기존의 django 에서 체크하고 있는 csrf 공격방어에 대한 인증을 제외하고 따로 인증절차를 진행하게되는데, 인증 유저를 익명유저로 설정하여 유저에 대한 권한검사를 하지 않고 default로 설정이 된 권한체크 클래스로 검사를 한다.<br>AllowAny는 접근 허용여부를 모두 True로 반환하여 접근에 대해 유효하다고 판단하여 csrf토큰 없이 요청 수행이 가능한 것이다.<br>데이터를 모두 처리하고 나서의 응답값은 Response 객체를 반환함으로서 처리한다.</p><p>2.View ↔ ajax (post, get)<br>ajax를 통해 View class에 메소드를 호출하는 경우는 많지는 않았는데, 이유는 굳이 ajax로 호출하지 않아도 할 수 있는 방법들이 있었기 때문이었다.<br>하지만 종종 사용해야할 경우가 있었는데, 이를테면 내부 검색창에서 검색결과를 내부 포멧에 맞게 내용을 채워줘야 하는데 그 template가 별도의 파일로 있는 경우였다.</p><ul><li>template.html</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#searchFrom"</span>).submit(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user_id = $(<span class="string">"input[name=user_id]"</span>).val();</span><br><span class="line"> </span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">"&#123;% url 'user:search' %&#125;"</span>,</span><br><span class="line">        type: <span class="string">"POST"</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            <span class="string">"csrfmiddlewaretoken"</span>: <span class="string">"\&#123;\&#123; csrf_token \&#125;\&#125;"</span>,</span><br><span class="line">            <span class="string">'user_id'</span>: user_id,</span><br><span class="line">        &#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">'#user_list tbody'</span>).html(response);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>위의 tempalate에서 입력받은 데이터를 통해 ajax로 호출을 한다. 이 때 호출되는 class는 View를 상속받은 class 이다. form의 submit으로 호출을 한 경우인데 form에 {% csrf_token %}이 들어가있기 때문에 post요청을 날릴 경우엔 403이 떨어진다.(get요청은 안넣어도 상관없다.)이런 경우를 방지하기 위해 data필드에 csrf token 을 넣어준다.<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"csrfmiddlewaretoken"</span>: <span class="string">"&#123;&#123; csrf_token &#125;&#125;"</span>,</span><br></pre></td></tr></table></figure><p>요청을 받고 데이터를 만들고 나면 TemplateResponse를 사용하여 분리되어 생성된 페이지를 반환하게 된다.</p><ul><li><a href="http://view.py" rel="external nofollow noopener noreferrer" target="_blank">view.py</a></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSearchView</span>(<span class="title">View</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(<span class="keyword">self</span>, request)</span></span><span class="symbol">:</span></span><br><span class="line">        user_id = request.POST.get(<span class="string">'user_id'</span>)</span><br><span class="line">        user_list = service.search_user(user_id)</span><br><span class="line">        context = &#123;</span><br><span class="line">            <span class="string">'user_list'</span>: user_list</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TemplateResponse(request, <span class="string">'user/user_list.html'</span>, context)</span><br></pre></td></tr></table></figure><p>다시 template에서는 넘어온 html덩어리를 미리 정의해둔 위치에 그대로 붙여줌으로서 화면을 다시 그리지 않고, 필요한 부분만 넣어줄 수 있다.<br>(APIView등을 통해 데이터만 받아와 다시 그리는 방법도 있지만 성격이 맞지 않는다고 생각하였고, 일반 호출을 하게 되면 페이지로딩을 다시 하므로 그 방법은 피했다)</p>]]></content>
      
      
        <tags>
            
            <tag> django </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python에서 iOS, Android 스토어 인앱 결제 검증하기</title>
      <link href="/2016/03/11/store-inapp-in-python/"/>
      <url>/2016/03/11/store-inapp-in-python/</url>
      <content type="html"><![CDATA[<p>Django framework를 이용해서 프로젝트를 만들면서 했던 여러가지 삽질들과 넘어야했던 많은 산들과 몰랐던 부분들에 대해서 내 나름 공부 겸 기록을 위해 남겨둬야 겠다는 생각이 들었다. 프로젝트로 한창 바빴던 시기에는 당장 앞에 놓여진 일들에 치여 이런 생각을 못하고 있다가 지금은 조금 여유가 되어 그 때 있었던 일들에 대한 나름의 경험을 기록해보고자 한다.</p><p>그 중에 한가지가 인앱 아이템 결제하기 였다. 나는 예전에 cocos2d-x로 게임을 개발했던 시절엔 결제 프로세스를 클라이언트(단말기)사이드만 알고 있었고 서버사이드의 로직은 전혀 모르고 있었는데, 오히려 이번에 서버 로직을 구현하면서 그 때 그 시절의 경험이 많은 도움이 되었다. 앱 내에 아이템을 구매하고 구매한 아이템을 유저에게 잘 넣어주는 로직이야 구현방식도 다양하고 여러 기교들이 들어가 있는데 오늘은 그 중에서 나름 간단한(?) 파트인 두 플랫폼의 결제 영수증 검증 로직의 삽질 경험을 적어보고자 한다.</p><p>이번에 대응했던 클라이언트는 google play store와 iOS app store 두개의 플랫폼이다. 차례차례 훑어보자.<br>각 플랫폼별 스토어의 앱 등록과 각종 키발급 같은 내용은 다루지 않고 순수하게 영수증 검증만을 볼 것이다.</p><ol><li>google In-app billing<br>구글 결제 영수증 검증의 경우 생각보다 단순해서 처음에는 이게 맞나? 싶었다. 일반적으로 생각하기에는 구글의 결제서버에 영수증 정보를 넘겨 유효한 영수증인지 여부를 판단해서 진행이 되는줄 알았는데(이렇게 하는 방법도 있다고 한다.), 훨씬 간단한 방법이 있었다. 암호화된 영수증 정보를 클라이언트로 부터 받아와서 local에서 검증하는 방식이다.</li></ol><p>일단 pip를 이용해서 Crypto 라이브러리를 설치하도록 하자.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> pycrypto</span><br></pre></td></tr></table></figure><p>다음은 영수증 검증 코드이다. signed_data 는 안드로이드 결제완료시 넘어온 암호화된 영수증 문자열이고 signature는 클라이언트와 약속된 특정 문자열이다. 안드로이드에서 결제를 요청할 당시 이 값을 함께 넘겨주면 signed_data 내부에 이 signature 값이 심어들어가게 되고, 복호화를 하면 이 값이 풀어져 나와 영수증 검증을 할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Signature <span class="keyword">import</span> PKCS1_v1_5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your base64 encoded public key from Google Play.</span></span><br><span class="line">PUBLIC_KEY_BASE64 = <span class="string">'YOUR_PUBLIC_KEY_BASE64'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify_for_google</span><span class="params">(signed_data, signature)</span>:</span></span><br><span class="line">    <span class="string">"""Returns whether the given data was signed with the private key."""</span></span><br><span class="line">    key = RSA.importKey(_pem_format(PUBLIC_KEY_BASE64))</span><br><span class="line">    verifier = PKCS1_v1_5.new(key)</span><br><span class="line">    data = SHA.new(signed_data.encode(<span class="string">'utf8'</span>))</span><br><span class="line">    sig = b64decode(signature)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> verifier.verify(data, sig)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pem_format</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'\n'</span>.join([</span><br><span class="line">        <span class="string">'-----BEGIN PUBLIC KEY-----'</span>,</span><br><span class="line">        <span class="string">'\n'</span>.join(_chunks(key, <span class="number">64</span>)),</span><br><span class="line">        <span class="string">'-----END PUBLIC KEY-----'</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_chunks</span><span class="params">(s, n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(<span class="number">0</span>, len(s), n):</span><br><span class="line">        <span class="keyword">yield</span> s[start:start+n]</span><br></pre></td></tr></table></figure><p>먼저 스토어에서 발급받은 공개키가 필요하다. 이 키를 이용해 넘어온 데이터가 유효한지 여부를 판단할 수 있다.</p><ol><li>RSA 암호 방식으로 암호화가 되어 있기 때문에 PUBLIC KEY 를 이용해 key객체를 생성한다.</li><li>PKCS(Public Key Cryptography Standard)를 이용해서 암호화된 영수증을 검증 할것이다. 1번에서 만들어진 key를 이용해 verifier 객체를 생성하자.</li><li>SHA(Secure Hash Algorithm)으로 된 signed_data를 객체로 생성한다.</li><li>signature 를 decode 한다.</li><li>2번에서 생성한 verifier를 통해 data 와 sig 의 유효성을 판단한다. 유효한 영수증은 True 그렇지 않으면 False 를 반환한다.<br>이 부분에 대해서는 좀 더 공부가 필요해 보인다… 현재는 암호화에 대한 꼭지들이 의미하는 바를 인지해야겠지만 이들이 어떤 작업을 하는지에 대한 공부도 반드시 필요할 것이다.<br>코드 내용이 그리 간단하지는 않지만 비교적 빠르게 구글 영수증 검증을 할 수 있었다. 구글의 개발자 사이트를 들어가 이런 저런 글도 읽오보고 여러 포스팅을 찾아보면서 여러가지 자료를 봐왔었는데 stackoverflow 에서 찾은 글들을 추려 간단하게 메소드로 정리했다. 내가 여기서 삽질 했던 부분은 대체 signed_data 와 signature 가 무엇을 뜻하는지 알 수가 없었다는 점이였다. 대부분의 자료들에서는 저 둘이 무엇을 의미하는지 자세히 기술을 해놓지 않거나 아예 어떤 값을 의미하는지를 써놓지 않은 글들이 많았다. 나도 처음에는 이리저리 고민을 해보다가 일단 맨땅에 헤딩을 하고보자는 마음으로 여러 땅에 삽집을 하다가 찾은 결과물이다.</li></ol><ol start="2"><li>iOS in-app purchase<br>이번에는 iOS결제 영수증 검증을 해보도록 하자. apple은 구글과는 다르게 결제 서버에 영수증을 보내서 넘어온 값을 통해 영수증의 유효성을 판단한다. 직접 apple의 결제 api를 호출해서 검증을 해도 되지만 역시나 Python은 있을만하다고 생각하는 라이브러리는 이미 존재하거나 누군가가 만들어 놨다. 우리는 이 라이브러리를 만든분 께 감사를 드리며 코드를 받아가도록 하자.</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> itunes-iap</span><br></pre></td></tr></table></figure><p>itunes-iap를 설치하면 의존성 라이브러리들이 이것저것 왕창 설치된다. 궁금하면 ($pip list 를 통해 확인해볼것)<br>이번에는 iOS 영수증 검증 코드를 보도록 하자. 이 때 transaction_id 는 결제 당시 결과값으로 오는 구매 영수증 id이고, raw_data는 암호화된 영수증 문자열이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itunesiap</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_verify_for_ios</span><span class="params">(transaction_id: str, raw_data: str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    seeAlso : https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html</span></span><br><span class="line"><span class="string">    :param transaction_id: 결제 transaction_id</span></span><br><span class="line"><span class="string">    :param raw_data: base64-encoded data</span></span><br><span class="line"><span class="string">    :return: boolean</span></span><br><span class="line"><span class="string">    :raises: Otherwise raise a request exception (RuntimeError, itunesiap.exc.InvalidReceipt)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># for sandbox environment.</span></span><br><span class="line">        <span class="comment">#     with itunesiap.env.sandbox:</span></span><br><span class="line">        <span class="comment">#         response = itunesiap.verify(raw_data)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># for production environment. (default)</span></span><br><span class="line">        response = itunesiap.verify(raw_data)  <span class="comment"># base64-encoded data</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_get_key</span><span class="params">(re)</span>:</span></span><br><span class="line">            <span class="string">""" 영수증리스트에서 비교 키를 반환합니다. """</span></span><br><span class="line">            <span class="keyword">return</span> re.purchase_date_ms</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 넘어온 in_app 영수증 리스트에서 구매 시각이 가장 마지막인 영수증을 가져와서 transaction_id를 비교한다.</span></span><br><span class="line">        <span class="comment"># 오름 차순으로 정렬해서 구매시각이 가장 마지막 영수증을 가져옵니다.</span></span><br><span class="line">        receipts = sorted(response.receipt.in_app, key=_get_key)</span><br><span class="line">        last_receipt = receipts[len(receipts) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> last_receipt.transaction_id != transaction_id:</span><br><span class="line">            <span class="comment">#  구매시각이 가장 마지막인 영수증의 transaction_id 가 일치 하지 않는다.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response.status == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>iOS 영수증 유효성 검증은 간단하다. itunesiap.verify 메소드를 통해 iOS에서 넘어온 데이터를 넣고 호출하면 복호화된 영수증 데이터가 나온다. 이 때 status 값이 0 이라면 유효한 영수증이라고 판단한다. 뭔가 apple다운 api라고 생각한다. 처음 iOS영수증 검증을 할 당시엔 verify 메소드만 호출하고 그 뒤에 넘어온 데이터의 status 값만 확인하고 유효성을 검증했다.<br>여기서 나의 삽질이 시작되었다.</p><ol><li><p>일단 주석에서 보는것과 같이 sandbox환경과 real환경일 때에 호출하는 api가 다르다. itunesiap의 환경을 설정을 해주는 방법은 여러가지가 있다. 각자 개발환경에서 영수증 유효성을 검사할 때엔 sandbox와 real환경을 잘 구분해서 api를 호출해주도록 하자. 아무리 유효한 영수증이라 할지라도 틀린 환경의 api를 호출하면 유효하지 않다고 판단하기 때문이다.</p></li><li><p>보통 verify 메소드를 호출하면 receipt 값 안에 하나의 영수증 정보만 가져온다. 하지만 특정 상황의 경우 receipt 데이터 안에 1개 이상의 영수증 정보가 딸려 오는 경우가 있다. 이 때에 한가지 데이터만이 유효한 영수증 값이다. 이 중에서 한가지 영수증만을 가지고 검증을 해야 하는데 여러 삽질 후에 깨달은 바는 receipt 안의 데이터들의 purchase_date_ms 값을 이용해 가장 마지막에 결제된 영수증 정보가 파라메터로 넘어온 transaction_id 와 동일하다는 점을 알게 되었다. 그래서 _get_key 메소드를 통해 receipt 리스트를 정렬하고, 그 중에 가장 마지막 영수증 정보를 뽑아 transaction_id 가 같은지 여부를 판단한다.</p></li></ol><p>자 이제 우리는 python을 이용해서 android, iOS의 영수증을 검증할 수 있게 되었다. 간단하지도 복잡하지도 않고, 몰랐을 때는 어려워 난해했지만 알고나니 더 난해한 비교적 간단하게 할 수 있는 파트였다. 이제 어디가서 이 두 플랫폼의 결제 영수증쯤은 아무렇지도 않게 검증 할 수 있다고 당당히 얘기하자.</p>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> ios </tag>
            
            <tag> android </tag>
            
            <tag> inapp </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
