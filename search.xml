<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>카카오페이지 검색 개발 후기</title>
      <link href="/2018/04/29/elasticsearch-with-kakaopage/"/>
      <url>/2018/04/29/elasticsearch-with-kakaopage/</url>
      <content type="html"><![CDATA[<h3><span id="elasticsearch-의-검색을-사용하기-까지">elasticsearch 의 검색을 사용하기 까지</span></h3><p>사내에서 elasticsearch 를 처음 사용하면서 로그 수집정도에만 사용하고 있었다. 워낙에 <a href="https://www.elastic.co/kr/elk-stack" rel="external nofollow noopener noreferrer" target="_blank">elk</a> 가 서로 잘 작동하기도 했고 데이터 수집부터 분석까지 너무나도 유려한 기능들을 갖추고 있었다. 서비스에서의 검색을 처음 도입해본 경험은 사내 정산 시스템을 만들면서 였는데, 작품이름 검색이나 작가등의 이름으로 검색을 하게 해달라는 요청이 있어서 였다.<br>데이터가 db 에 있어 단순하게 like 검색으로 구현할까 했었는데, 생각보다 결과에 대한 품질이 너무 낮았다. 결과에 대한 점수 부여 방법도 딱히 없고 애초에 조건이 하나만 걸리니 내가 원하는 결과를 얻을 수 없었다.<br>그래서 안되겠다 싶어 elasticsearch 와 은전한닢을 이용해 구현했고,  거기서 자신감이 생겨 서비스의 검색도 과감하게 elasticsearch 로 구현하자고 주장했다. 처음에 회사에서는 반기는 분위기는 아니였다.<br>기존에 (나름 잘) 동작하는 검색이 구현되어 있었고 한번도 도전해보지 않은 검색이라는 서비스를 잘 구현할 수 있을까에 대한 걱정이 있었다. 그리고 이미 카카오에서 제공하는 검색엔진이 있고 이를 이용하면 우리쪽에서 굳이 만들 이유가 없어서 였다. 카카오에서 제공하는 기능들을 이용하기만 해도 되었지만 앞으로 우리가 우리만의 기술을 갖게 된다면 그 자체로 의미가 있다 생각했고, 결과로 보여드려야겠다고 생각해서 나는 카카오페이지의 검색을 만들어 보기로 했다.</p><h3><span id="기존-구성">기존 구성</span></h3><p>나는 일단 기존의 검색이 어떻게 동작하고 있는지 부터 분석을 해보기로 했다. 지정된 시간마다 단어들을 수집해서 잘게 쪼갠 뒤 테이블에 데이터를 저장해놓고, 실제 서비스에서는 나름의 공식을 이용해 점수를 부여해서 검색 결과를 내어주는 방식이었다. mysql 의 fts 를 이용한 방식이었는데 나름 속도도 괜찮고 완벽하진 않았지만 검색의 결과도 그리 나쁘지는 않았다.<br>처음에는 이 검색 서비스부터 이겨보자는 생각으로 다른 검색 서비스들이 검색을 어떻게 서비스 하고 있는지 부터 관찰했다. 개발 초기에는 <a href="https://ridibooks.com/" rel="external nofollow noopener noreferrer" target="_blank">리디북스</a>나 <a href="https://www.lezhin.com/ko" rel="external nofollow noopener noreferrer" target="_blank">레진코믹스</a> 같은 사이트들의 검색을 많이 참고했다.</p><h3><span id="은전한닢">은전한닢</span></h3><p>한글 형태소 분석기는 크게 3가지가 있다. <a href="https://www.elastic.co/kr/blog/using-korean-analyzers" rel="external nofollow noopener noreferrer" target="_blank">elasticsearch 에서 제공하는 형태소분석기 분석</a>에서 보면 arirang, 은전한닢 그리고 open-korean-text(구 twitter-korean-text) 등이 있는데 각 장단점들이 명확해서 아직까지는 형태소 분석기의 절대적인 강자는 없는듯 하다.<br>각자 자신에게 맞는 형태소 분석기를 사용하면 되는듯 한데, <a href="https://www.ridicorp.com/blog/2016/04/18/ridibooks-stack/" rel="external nofollow noopener noreferrer" target="_blank">리디북스에서 은전한닢을 사용하다는 기술 블로그</a>를 보고 생각의 결과가 많이 굳기도 했지만 음절 분석결과가 가장 자세하고 속도도 괜찮은 은전한닢을 사용하기로 했다.</p><h3><span id="클러스터-구성">클러스터 구성</span></h3><p>2대의 노드로 클러스터를 구성해서 검색 색인을 하고 있고, 주기적으로 추가/변경되는 정보들을 인덱스에 반영하고 있다. 추가적으로 실제 서버 데이터와 개발에서의 구성도 elasticsearch 로 구성했는데, 테스트 서버군은 하나의 노드로 구성했고 각 테스트군별로 색인을 따로 구성했다.</p><h3><span id="데이터-수집및-정제">데이터 수집및 정제</span></h3><p>검색 쿼리만큼이나 중요한 부분이 데이터 수집이다. 어찌보면 색인이 얼마나 잘 되어 있느냐에 따라 검색 결과의 품질이 좌우된다. 색인과 검색의 비율을 따져 생각해본다면 6:4 정도라고 생각한다. 아무리 많은 데이터를 사용한다 하더라도 데이터가 잘 저장되어 있지 않으면 아무런 소용이 없기 때문이다.<br>일단 데이터를 주기적으로 수집하기로 했고, 카카오 검색팀의 조언을 받아 단어에 대한 점수에 대한 결과도 함께 수집을 한다. logstash 로 처음에는 데이터를 수집하려고 했는데 점수부여에 대한 로직이나 데이터 정제의 편의성을 위해 배치작업을 데이터를 수집했다. 간략하게 수집되는 정보들을 보면 다음과 같다.</p><ul><li>열람수, 구매자수, 인기도, 기다리면 무료의 대한 점수 계산</li><li>랭킹데이터 수집</li><li>(정산 시스템 구축의 경험으로) 계약 주체에 따른 점수 부여</li><li>운영자가 등록한 태그 수집</li><li>작품명, 작가명, 발행자명, 출연진등의 정보 수집</li></ul><p>가능한 모든 정보를 수집하고자 했고, 은전한닢으로 기분석된 단어와 순수한 단어를 따로 인덱싱을 했다. 이유는 나중에 검색부분에도 언급하겠지만 한글 형태소 분석기로 분석된 단어와 그렇지 않은 단어를 함께 검색 쿼리에 넣어 검색의 결과를 높이기 위함이다. 형태소 분석기를 통해 토크나이징을 하게 되면 자체적으로 단어를 쪼개게 되는데, 이 때 원치 않게 단어가 나뉠수도 있기 때문이다.<br>예를 들어 <code>김비서</code> 이라는 단어를 형태소 분석기에 넣고 돌리면 엉뚱한 결과가 나온다.</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">김비서</span><br><span class="line">김비NNP,인명,F,김비,<span class="strong">*,*</span>,<span class="strong">*,*</span></span><br><span class="line">서JKB,<span class="strong">*,F,서,*</span>,<span class="strong">*,*</span>,<span class="strong">*</span></span><br><span class="line"><span class="strong">EOS</span></span><br></pre></td></tr></table></figure><p>일반적으로 생각했을 때 <code>김</code>, <code>비서</code> 로 나올거라 예상했지만 결과는 이와는 달리 <code>김비</code>, <code>서</code> 로 나뉘게 되버린다. 원인은 제공되는 정보가 부족해서인데, 모든 문장을 써주면 정상적으로 표시 된다.</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">김비서가왜그럴까</span><br><span class="line">김NNP,인명,T,김,<span class="emphasis">*,*</span>,<span class="emphasis">*,*</span></span><br><span class="line">비서NNG,<span class="emphasis">*,F,비서,*</span>,<span class="emphasis">*,*</span>,*</span><br><span class="line">가JKS,<span class="emphasis">*,F,가,*</span>,<span class="emphasis">*,*</span>,*</span><br><span class="line">왜MAG,문장부사/양상부사,F,왜,<span class="emphasis">*,*</span>,<span class="emphasis">*,*</span></span><br><span class="line">그럴까VA+EC,<span class="emphasis">*,F,그럴까,Inflect,VA,EC,그렇/VA/*</span>+ᆯ까/EC/*</span><br></pre></td></tr></table></figure><p>이런식의 토크나이징은 검색에서도 문제가 된다. elastisearch 에서 검색을 태우면 색인되어 있는 타입에 따라 기분석해서 나온 토큰들로 검색을 하게 되는데 사용자가 <code>김비서</code> 라고 검색을 하게 되면 <code>서</code> 라는 토큰이 나오게 되기 때문에 엉뚱한 검색 결과가 나오게 된다.<br>추가적으로 난감했던 단어는 <code>하라간</code> 과 같이 사전에 등록되지 않은 고유명사들의 경우였다. 은전한닢은 세종 말뭉치를 사용하고 있는데, 비교적 최근에 추가되는 신조어들이나 작품에서 의도적으로 사용되는 고유명사들에 대한 데이터는 존재 하지 않는다. <code>하라간</code> 의 경우엔 형태소 분석기에서는 아예 알아들을 수 없는 단어가 되어버린다.</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">하라간</span><br><span class="line">하VV,<span class="strong">*,F,하,*</span>,<span class="strong">*,*</span>,<span class="strong">*</span></span><br><span class="line"><span class="strong">라EC,*</span>,F,라,<span class="strong">*,*</span>,<span class="strong">*,*</span></span><br><span class="line">간NNG,<span class="strong">*,T,간,*</span>,<span class="strong">*,*</span>,<span class="strong">*</span></span><br><span class="line"><span class="strong">EOS</span></span><br></pre></td></tr></table></figure><p>(…여기서 멘붕이 왔었다.)<br>임시방편으로 사용했던 방법은 mecab 에서 제공하는 사용자 사전이었는데, 인명이나 지명등의 단어를 넣으면 형태소 분석기에서 의도적으로 단어를 쪼개지 않고 단어 그자체로서 인식을 가능하게 한다.<br>하지만 4만개가 넘는 모든 작품들을 모니터링하고 일일히 결과를 들여다보면서 사용자 사전에 필요한 단어들을 넣는건 나 혼자 작업으로는 불가능했었고, 처음에는 사용자 cs 나 내부적으로 결과가 이상한 단어들에 대해서만 사전에 등록했었다. (사용자 사전은 나중에 좀 더 자세하게 이야기 해보자.)</p><h3><span id="데이터-색인">데이터 색인</span></h3><p>데이터는 항상 추가된다. 하지만 판매중이었다가 여러 이유로 판매가 중지되는 작품도 있고 운영자에 의해 작품의 정보가 변경되는 일도 꽤나 잦았다. 이미 존재하는 필드에 값을 갱신하려고 했더니 경우의 수가 너무 많았다. 모든 상황에 대해 신시간으로 대응하기 위해서 <a href="https://www.elastic.co/kr/blog/changing-mapping-with-zero-downtime" rel="external nofollow noopener noreferrer" target="_blank">다른 곳에서 아이디어</a>를 얻었는데 elasticsearch 에서 제공하는 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.2/indices-aliases.html" rel="external nofollow noopener noreferrer" target="_blank">alias</a> 와 일반적인 <a href="http://en.dwhwiki.info/concepts/blue-green-development" rel="external nofollow noopener noreferrer" target="_blank">blue-green deploy</a> 방법을 이용해서 모든 데이터를 주기적으로 새로 갱신하는 방법을 이용했다. <code>index-blue</code>, <code>index-green</code> 를 하나씩 생성하고 <code>index</code> 라는 <code>alias</code> 를 걸어 실제 검색 쿼리는 <code>index alias</code> 를 바라보게 했다. 데이터 수집 배치는 독립적으로 동작하고 있기에 실시간으로 필드를 추가하는 장점도 함께 가져갈 수 있다.</p><h3><span id="검색-쿼리">검색 쿼리</span></h3><p>초기의 버전에서는 사용자 사전을 최대한 사용하지 않는 방향으로 진행했었다. 위에서 언급한 바와 같이 모든 고유명사들을 수동으로 쪼개는 작업이 물리적으로 불가능했었기 때문인데, 이런 제한을 극복하고자 최대한 검색 쿼리를 세부적으로 쪼개서 검색의 결과를 높이고자 했다.<br>mapping 에서 title 에 관련된 정보는 다음과 같이 구성했다.</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"title"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">    <span class="string">"analyzer"</span>: <span class="string">"seunjeon_analyzer"</span></span><br><span class="line">&#125;,</span><br><span class="line"><span class="string">"titleBigram"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">    <span class="string">"analyzer"</span>: <span class="string">"han_bigrams"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">"titleStandard"</span>: &#123;</span><br><span class="line">    <span class="string">"type"</span>: <span class="string">"text"</span>,</span><br><span class="line">    <span class="string">"analyzer"</span>: <span class="string">"exact"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="http://eunjeon.blogspot.kr/" rel="external nofollow noopener noreferrer" target="_blank">은전한닢</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-cjk-bigram-tokenfilter.html" rel="external nofollow noopener noreferrer" target="_blank">bigram</a></li><li>띄어쓰기등을 제거한 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html" rel="external nofollow noopener noreferrer" target="_blank">standard analyzer</a></li></ul><p>검색 쿼리를 수행시 3개의 필드에 대해 각기 다른 boost 를 줘서 가장 근접한 결과에 대해 점수를 높게 부여해서 결과를 만들었다. bigram 을 사용한 이유는 앞서 언급한 형태소 분석기의 한계를 대체하기 위해 색인되는 단어들을 ngram 으로 조개어 저장해서 엉뚱한 결과가 나오는 것에 대한 대처였다. (나중에 다시 언급하겠지만 결과적으로는 <code>bigram</code> 을 사용하지 않게 되었다.)<br><code>MatchQuery</code> 로 검색을 하는데 위에서 언급한 대로 기분석된 색인이 엉뚱하게 저장되는 경우들이 꽤나 빈번했기 때문에 초기 검색결과는 가히 충격적이었다. 왜 이 단어가 검색이 되었지? 하는 결과들이 포함되어 있었기 때문이었다. 이후에 카카오 검색셀의 조언을 받아 쿼리는 대대적으로 튜닝하게 되었다.</p><h3><span id="elasticsearch-버전-관리">elasticsearch 버전 관리</span></h3><p>개발 초기에는 elasticsearch 최신 버전이 5.1.1 이었다. 검색 서비스를 라이브에 반영하게 되고 보니 버전은 6.x 까지 올라가버렸다. 요즘 추세인지는 모르겠지만 어째 버전업이 너무나도 빠르게 진행되고 있었다. 이전 포스트에서도 얘기 했었던 <a href="https://www.elastic.co/support/eol" rel="external nofollow noopener noreferrer" target="_blank">elasticsearch 기술 지원</a> 때문에라도 elasticsearch 버전을 주기적으로 (꽤나 빈번하게) 올리기도 했다. rolling upgrade 에 대한 내용은 <a href="https://nevercaution.github.io/2018/03/15/elasticsearch-rest-client/">여기</a>에서 자세하게 다루었다.</p><h3><span id="쿼리-튜닝">쿼리 튜닝</span></h3><p>사용자 사전 없이 <code>title</code>, <code>titleBigram</code>, <code>titleStandard</code> 만들어 검색쿼리를 날리면 정말 검색 결과가 엉뚱하게 나오는 경우가 있다. 위에서도 언급한 토크나이징 때문인데 이는 사용자 사전 없이는 사실상 불가능 하다. 사용자 사전을 추가하고 난 후에는 bigram 은 사용하지 않고 <code>title</code>, <code>titleStandard</code> 두 필드를 사용해서 <code>MatchQuery</code> 를 날린다. <code>bigram</code> 도 결국에는 단어를 ngram으로 추출하는 방식인데 근본적인 해결책이 되진 못하기 때문이다.<br>그리고 <code>FunctionScoreQuery</code>, <code>FilterFunction</code> 를 이용해서 결과에 대한 점수 부여를 추가했다. 점수 부여에 관한 로직은 카카오 검색셀(hao) 의 도움을 받아 구현했는데, 위에서 데이터 수집당시에 점수를 부여할 수 있는 판매량이나 열람수와 같은 정보를 이용해서 내부적인 공식을 적용해서 점수를 부여했다.<br>쿼리 튜닝이라고는 했지만 결과적으로는 인덱싱할 때부터 데이터를 잘 만드는게 큰 도움이 되었다. 잘 만들어진 데이터가 있어야 좋은 검색이 나올 수 있기 때문이다.</p><h3><span id="사용자-사전-관리">사용자 사전 관리</span></h3><p>내가 의도한대로 토크나이징이 되기 위해 결국엔 사용자 사전을 추가하게 되었다. 또한 신조어들의 대한 대응을 하기 위함이었는데, 예를 들어 <code>레벨업</code> 이라는 단어가 포함된 작품을을 검색할 때 기존에는 <code>레벨</code> 과 <code>업</code> 으로 쪼개버린다.</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">레벨업</span><br><span class="line">레벨NNG,<span class="strong">*,T,레벨,*</span>,<span class="strong">*,*</span>,<span class="strong">*</span></span><br><span class="line"><span class="strong">업NNG,*</span>,T,업,<span class="strong">*,*</span>,<span class="strong">*,*</span></span><br><span class="line">EOS</span><br></pre></td></tr></table></figure><p>이 경우에는 <code>업</code> 이라는 단어가 포함된 작품들도 함께 결과에 포함되기 때문에 전혀 엉뚱한 작품들이 포함되기도 한다. <code>레벨업</code> 이라는 단어를 사전에 고유명사로 등록해서 최대한 엉뚱한 결과가 없게끔 했다.<br>그렇다면 전체 작품에 대해 어떻게 원하는 고유명사를 추출할 수 있을까?<br>이 고민에 대한 해결책은 기존의 검색용 수집 데이터를 사용했다. 운영자가 작품을 등록할 때 <code>태그</code> 를 함께 등록하는데 이는 기존에 검색에서 사용되었던 검색 태그들이다. <code>김비서거 왜그럴까</code> 같은 경우엔 <code>김비서</code> 나 <code>김명미</code> 등의 태그들을 걸어두어서 기존의 검색에서 사용할 수 있는 데이터를 제공했었다. 이 데이터를 약간 손봐서 사용가능한 단어들에 대해 사용자 사전에 등록해서 완벽하진 않지만 신조어나 고유명사들에 대한 대응을 했다.<br>데이터가 없는 경우에 뉴스기사나 다른 데이터를 학습해서 토크나이징을 할 수 있는 <a href="https://github.com/lovit/soynlp" rel="external nofollow noopener noreferrer" target="_blank">soynlp</a> 같은 훌륭한 오픈소스도 참고할까 싶었지만 개발 시간에 대한 한계도 있었고(핑계지만), 검색 결과에 대해 스스로 보장하기 어렵다는 이유로 도입을 하진 않았다. 나중에 여유가 되면 학습을 통한 토크나이져를 추가해볼까도 고민중인 부분이다.<br>추가적으로 구글에서는 <a href="https://cloud.google.com/natural-language/?hl=ko" rel="external nofollow noopener noreferrer" target="_blank">자연어분석</a> 서비스를 내놓았다. 어쩌면 가까운 미래에는 한글 형태소 분석기가 없어도 한글 검색이 가능해질지도 모르겠다.</p><h3><span id="결론">결론</span></h3><p>아직 카카오페이지의 검색은 완벽하지 않다. 여전히 특정 검색어에서는 엉뚱한 결과가 나오기도 하고 의도한 대로의 순서가 보장되지 않는 경우도 있다. 스스로도 만족할만한 수준의 서비스는 아니지만 계속해서 데이터 수집이나 검색 쿼리에 대한 튜닝들에 대한 고민을 하고 있다.  네이버나 카카오의 검색엔진에 비교해서는 많이 부족하지만 그렇기에 앞으로도 더욱 더 좋은 검색 서비스를 만들 수 있음을 기대해본다.</p>]]></content>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
            <tag> kakaopage </tag>
            
            <tag> 은전한닢 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring boot Custom Annotation 사용하기</title>
      <link href="/2018/04/15/spring-boot-custom-annotation/"/>
      <url>/2018/04/15/spring-boot-custom-annotation/</url>
      <content type="html"><![CDATA[<h3><span id="썰의-시작">썰의 시작</span></h3><p>회사에서 msa 를 눈여겨 보면서 하나로 합쳐져 있는 거대한 프로젝트를 각각 쪼개려는 시도들을 하고 있다. 일에 치여 마음속에서만 맴돌고 있다가 최근에 새로운 기능을 추가해야할 일이 생겨 이때다 싶어 과감히 프로젝트를 쪼개서 작업해보기로 했다.<br>기존에 있던 api server 와 internal 호출을 하면서 데이터를 주고받는 작은 api service 이다. view 가 없기 때문에 Restful 하게 만들었다. (<s>내가 front 작업이 약해서는 아니다!</s>)<br>새로 추가된 서비스(<code>mini api server</code> 라고 하자)에서만 사용하는 테이블들이 있고, 기존 <code>api server</code> 는 <code>mini api server</code> 과 통신을 해서 해당 정보들에 대한 CRUD 를 할 수 있다.<br>최대한 기존 서비스와는 별도로 작업을 하고자 했고 추후에 물리 디비가 나뉘어도 큰 작업없이 옮겨갈 수 있도록 결합도를 낮추고자 했다.<br>user 에 대한 데이터는 sharding 되어있고 현재는 디비를 같은 곳에 사용하고 있기 때문에 같은 sharding 전략을 가져가야 한다.</p><p>annotation 얘기를 해야하는데 갑자기 엉뚱한 소리가 나왔네라고 생각할지도 모른다. 결론적으로 내가 해야할 일은 user 가 어느 shard 번호를 배정받았는지를 알아야 한다. 이 작업을 annotation 을 이용해서 유려하게 처리해도록 하자.</p><h2><span id="구현목표">구현목표</span></h2><p>controller 에서 <code>@RequestParam</code> 으로 받은 값중에 특정값은 데이터가 sharding 처리가 되어 있어 각 repository 에서는 각 분배되어 있는 데이터를 잘 조회하기 위해 해당 디비번호를 설정해주어야 한다. 내가 구현해야할 일을 정리해보자.</p><ul><li>user_uid 값은 sharding 처리가 되어 있다.</li><li>사용자는 user 가 어느 디비에 sharding 이 되어있는지 모른다.</li><li>repository 에서는 각 분배가 되어 있는 디비에 접근을 해야한다.</li></ul><p>이런 상황에서의 해결법은 여러가지가 있다. 간단하게 처리할 수도, 복잡하게 처리할 수도 있다.<br>하나씩 정리하면서 넘어가도록 하자.</p><h2><span id="개발-컨셉">개발 컨셉</span></h2><p>shard 번호를 처리를 해야한다고 할 때 두가지 방법으로 처리할 수 있다.</p><ul><li>사용자가 api 콜을 할 때 shard 번호를 함께 넘겨받는다.</li><li>shard 번호가 배정되어 있는 디비에 해당 사용자의 번호를 가져온다.</li></ul><h3><span id="shard-번호-넘겨받기">shard 번호 넘겨받기</span></h3><p>전자의 경우에는 <code>new api server</code> 에서 shard 번호를 알고 있을 필요가 없기 때문에 아무런 처리없이 해당 shard 번호를 세팅해주면 된다.<br>현재는 물리디비가 함께 있으므로 이렇게 처리해도 큰 문제가 없다. user 데이터가 같은 디비에 있어 shard 번호만 받으면 동일한 번호에 데이터가 있기 때문이다. 하지만 추후에 디비가 나뉘어져서 shard 전략이 다르게 될 때는 문제가 된다. <code>api server</code> 에서는 1번 shard 인데 new api server 에서는 2번 shard 번호를 배정받을 수 있기 때문이다. 이런 이유로 후자의 방법으로 방향을 잡게 되었다.</p><h3><span id="shard-번호-찾아가기">shard 번호 찾아가기</span></h3><p>shard 번호를 <code>mini api server</code> 에서 찾아가는 방법도 여러가지가 있다.</p><ul><li>별도의 service 를 만들어 명시적으로 호출해줘 값을 지정한다.</li><li>상위 cnotroller 를 만들어 전체 controller 는 부모 controller 를 상속받아 부모에서 처리한다 (기존 <code>api server</code> 방식)</li><li>interceptor, annotation 를 이용해 controller 전처리</li></ul><p>1, 2 번의 경우 각 api 호출별로 명시적으로 호출해서 처리할 수 있다. 다만 사용자가 모든 api 에 호출을 해주어야 하는 단점이 있고, 일단 마음에 들지 않는다. user 정보를 조회하는 api 에 모두 같은 로직을 넣어주어야 하기 때문에 코드 중복이 생기고 만약 실수로 코드를 넣지 않았다면 의도치 않은 에러를 발생할 수 있다. 최대한 중복코드를 줄이면서 사용자가 사용하기 편하게 하기 위해 annotation 을 사용해서 처리해보자.</p><h2><span id="custom-annotation">custom annotation</span></h2><p>최종결과물부터 보면 다음과 같다. <code>@RequestParam</code> 을 사용하지 않고 <code>@RequestCustomParam</code> 을 이용한다. 이 annotation 을 붙여두면 알아서 shard 정보를 조회해서 DataSource 에 세팅하고 결과값을 Integer 값으로 반환받아 비지니스 로직에서 사용할 수 있다.</p><p><code>FirstController</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/"</span>, method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">(@RequestCustomParam(value = <span class="string">"uid"</span>)</span> Integer uid) </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>자 이게 가능하게 하기 위해서 하나씩 처리과정을 따라가보자.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── TeddyApplication.java</span><br><span class="line">├── annotation</span><br><span class="line">│   └── RequestCustomParam.java</span><br><span class="line">├── config</span><br><span class="line">│   └── InterceptConfig.java</span><br><span class="line">├── controller</span><br><span class="line">│   └── FirstController.java</span><br><span class="line">└── handler</span><br><span class="line">    └── CustomResolver.java</span><br></pre></td></tr></table></figure><ol><li><code>RequestCustomParam</code> 을 생성</li><li><code>InterceptConfig</code> 에서 customResolver 를 등록</li><li><code>CustomResolver</code> 에서 <code>RequestCustomParam</code> 여부를 검사해 필요한 로직 실행</li><li><code>FirstController</code> 에서 필요한 param 값에 <code>@RequestCustomParam</code> 로 등록을 하고, 전처리 후 shard 세팅이 된 uid 정보 이용</li></ol><h3><span id="하나씩-살펴보자">하나씩 살펴보자</span></h3><p>하나씩 뜯어보면 그리 어렵지 않다. 대체 어떻게 동작하는 것일까.</p><p><code>RequestCustomParam</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestCustomParam &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>value 만 갖고 있으면 되고 다른 설정들은 일단 사용하지 않아서 <code>RequestParam</code> 에서 필요한 값만 가져왔다. 주목해야할 점은 Target 과 Retention 이다. Parameter 타입을 이용해 처리하고 RunTime 까지 annotation 을 가져가서 처리하도록 했다.</p><p><code>InterceptConfig</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addArgumentResolvers</span><span class="params">(List&lt;HandlerMethodArgumentResolver&gt; resolvers)</span> </span>&#123;</span><br><span class="line">        resolvers.add(getCustomResolver());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CustomResolver <span class="title">getCustomResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomResolver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WebMvcConfigurer</code> 를 붙여서 내가 생성한 resolver bean 을 등록해준다.</p><p><code>CustomResolver</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomResolver</span> <span class="keyword">implements</span> <span class="title">HandlerMethodArgumentResolver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsParameter</span><span class="params">(MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parameter.hasParameterAnnotation(RequestCustomParam.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        RequestCustomParam customParam = parameter.getParameterAnnotation(RequestCustomParam.class);</span><br><span class="line">        String value = webRequest.getParameter(customParam.value());</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> Integer.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>핵심이 되는 부분이다. <code>RequestCustomParam</code> 가 포함되어 있는지 여부를 검사해서 annotation 이 등록되어 있는 request 만 통과를 시킨다. 그리고 사용자가 등록한 value 값을 뽑아와서 필요한 로직처리를 해주면 된다.<br><code>// do sonething</code> 부분에서 shard 를 찾아가는 로직을 추가해주도록 하자.<br>전처리가 끝나면 controller 에서 uid 값을 이용해 비지니스 로직을 수행해야 하기 때문에 value 로 뽑아온 값을 다시 돌려준다.<br>여기서 참고할 부분은 parameter 로 뽑아온 값은 무조건 String 타입으로 반환된다. 각자 필요한 타입으로 변환해서 사용하도록 하자.<br>(아마 일반적으로 처리하기 위해 String 으로만 반환받게 한듯 싶다. 여러 타입으로 반환하는 것보다 처리가 간단하고 여러 타입으로 변환하는 작업 자체가 불필요하다고 느꼈을까)<br>신경써야할 부분이 있다면 <code>parameter.getParameterAnnotation</code>, <code>webRequest.getParameter</code> 은 <code>@Nullable</code> 이기 때문에 NPE 처리를 해주면 좋다.</p><p>이제 필요한 부분에만 <code>@RequestCustomParam(value = &quot;uid&quot;) Integer uid</code> 으로 명시해서 처리하면 사용자는 sharding 에 대한 로직을 신경쓰지 않아도 된다.<br>별도의 service 로 나누어 처리하는 것보다 명시적이고 중복코드 없이 간단하게 처리할 수 있다.</p><h2><span id="결론">결론</span></h2><p>지금까지 작업한 전체 코드는 <a href="https://github.com/nevercaution/customAnnotation" rel="external nofollow noopener noreferrer" target="_blank">여기</a> 에서 확인할 수 있다.<br>annotation 을 사용하면 특정 로직들은 뒤에서 처리되기 때문에 관심을 갖지 않고 보면 어떻게 동작하는지 이해하기 힘들다. 반대로 annotation 에 대한 이해가 있으면 코드는 훨씬 간결해지고 직관적으로 처리할 수 있게 된다. 이전까지는 annotation 은 알아서 동작하겠지 하며 큰 신경을 쓰고 있지 않았었는데, 직접 사용해보니 기존의 로직을 좀 더 깔끔하게 처리할 수 있다는 부분이 마음에 든다.</p>]]></content>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> annotation </tag>
            
            <tag> argumentresolver </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring Boot Actuator 를 이용해 버전 정보 제공하기</title>
      <link href="/2018/03/24/spring-boot-actuator/"/>
      <url>/2018/03/24/spring-boot-actuator/</url>
      <content type="html"><![CDATA[<h3><span id="지금-dev-서버에-배포되어-있는-서버-버전이-몇인가요">지금 dev 서버에 배포되어 있는 서버 버전이 몇인가요?</span></h3><p>회사에 서버환경은 dev, sandbox, test, beta, alpha, real 으로 나뉘어 있다. 각 단계별로 기능 테스트를 하고 QA를 통해 모든 기능이 개발 완료 되고 QA도 끝나면 real 서버에 배포가 된다.<br>나와 클라이언트 개발자는 먼저 dev 서버에서 새로운 기능이나 버그 수정등을 테스트 하는데 일정에 쫓길 때는 메이져 버전과 마이너 버전이 동시에 작업되서 두개의 버전을 두고 개발해야 하는 상황이 생기기도 한다.<br>젠킨스를 통해 해당 서버에 어플리케이션을 배포하는데 지금까지는 배포된 버전을 보기 위해선 젠킨스의 배포이력을 찾아 배포된 버전을 찾았어야 했었다. 여간 귀찮은 일이 아닐 수가 없다. 하지만 이 방법밖에는 없으니 얼른 클라이언트 개발자에게 현재 배포된 버전을 찾아서 알려주자.<br><code>build.gradle</code> 에 배포된 버전을 명시해놓고 있긴 하지만 jar로 묶인 패키지에는 버전을 알 수 있는 방법이 없다. 이런 설정정보들을 쉽게 확인할 수 있었으면 좋겠다.</p><h3><span id="지금-필요한-기능과-제약을-정리해보자">지금 필요한 기능과 제약을 정리해보자.</span></h3><p>처음엔 무작정 덤벼들까도 했지만 침착하게 숨을 고르고 내가 해야할 일을 정리해보았다.</p><ul><li>배포되는 서버환경별로 어플리케이션의 버전정보를 알고 싶다.</li><li>알기 쉽게 endpoint등의 방법으로 버전을 알려주고 싶다.</li><li>모듈이 여러개가 있기 때문에 현재 돌아가고 있는 어플리케이션의 이름정보등 여러가지를 알고 싶다.</li></ul><h2><span id="프로젝트의-구조를-살펴보자">프로젝트의 구조를 살펴보자</span></h2><p>spring-boot 로 구성된 프로젝트는 여러개의 모듈로 구성되어 있다. 각 프로젝트별로 기능들을 모아놓고 있으며 jar로 묶여 runnable한 모듈도 있고 common 이나 utils 같이 기능들을 모아놓은 모듈도 있다.<br>프로젝트의 설정은 아래와 같이 구성되어 있다.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">├── README.md</span><br><span class="line">├── api</span><br><span class="line">│   ├── README.md</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── batch</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── build.gradle</span><br><span class="line">├── common</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── elasticsearch</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">├── mongodb</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── mysql</span><br><span class="line">│   ├── build</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── redis</span><br><span class="line">│   ├── build.gradle</span><br><span class="line">│   └── src</span><br><span class="line">├── settings.gradle</span><br><span class="line">└── utils</span><br><span class="line">    ├── build.gradle</span><br><span class="line">    └── src</span><br></pre></td></tr></table></figure><p>runnable한 모듈들의 <code>build.gradle</code> 에는 각자 버전들이 명시되어 있다. <code>api</code> 모듈의 <code>build.gradle</code>을 살펴보자.</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'rebel'</span></span><br><span class="line">apply plugin: <span class="string">'org.springframework.boot'</span></span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    baseName = <span class="string">'api'</span></span><br><span class="line">    version = <span class="string">'9.2.8-SNAPSHOT'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':common'</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':mysql'</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':mongodb'</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':redis'</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':utils'</span>)</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">project</span>(<span class="string">':elasticsearch'</span>)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bootRun &#123;</span><br><span class="line">    systemProperties System.properties</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ext</code> 안에 모듈의 이름과 관리되고 있는 버전의 정보가 들어있다. 어떤 기능이 개발되어 질 때는 버전을 먼저 따고 그 버전에 기능들 개발해 넣게 된다. 클라이언트 개발자들과의 소통은 저 버전으로 하게 된다.<br>하지만 빌드를 하면 저 정보는 jar에 따라 오지 않기 때문에 jar파일만 가지고는 버전정보를 알 수가 없다.<br>안되는게 어디있는가 이제부터 저 정보들을 제공하는 방법들을 알아보도록 하자.</p><h2><span id="spring-boot-actuator">Spring boot actuator</span></h2><p>spring boot 에서 제공하고 있는 공식 모듈중에 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready" rel="external nofollow noopener noreferrer" target="_blank">spring boot actuator</a> 라는 모듈이 있다. 이게 무엇인고 하고 살펴보니 아래와 같이 정의가 되어 있다.</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Definition <span class="keyword">of</span> Actuator</span><br><span class="line"></span><br><span class="line">An actuator is <span class="keyword">a</span> manufacturing term that refers <span class="built_in">to</span> <span class="keyword">a</span> mechanical device <span class="keyword">for</span> moving <span class="keyword">or</span> controlling something.   </span><br><span class="line">Actuators can generate <span class="keyword">a</span> large amount <span class="keyword">of</span> motion <span class="built_in">from</span> <span class="keyword">a</span> small change.</span><br></pre></td></tr></table></figure><p>여러 정보들을 작은 작업으로 제공해준다니 내가 찾고 있던 것이 틀림없다. 기본적으로 여러 endpoint 들을 제공하고 있고 info 뿐만 아니라 health 나 metrics 등 여러 기능들을 제공하고 있다. 지금 필요한건 버전에 대한 정보들만 표시할 수있으면 되기 때문에 옆길로 새지말고 직진하도록 하자.<br>아무런 설정을 하고 않고 빌드를 하게 되면 build.gradle 에 명시되어 있는 버전 정보들은 빠지고 빌드가 되게 된다. actuator 을 추가해보자.</p><p><code>build.gradle</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 1 </span></span><br><span class="line">ext &#123;</span><br><span class="line">   baseName = <span class="string">'api'</span></span><br><span class="line">   version = <span class="string">'9.2.8-SNAPSHOT'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line">compile <span class="string">'org.springframework.boot:spring-boot-starter-actuator'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line">springBoot&#123;</span><br><span class="line">    buildInfo &#123;</span><br><span class="line">        additionalProperties = [</span><br><span class="line">                <span class="string">'version'</span>: <span class="string">"<span class="subst">$&#123;project.ext.version&#125;</span>"</span>,</span><br><span class="line">                <span class="string">'name'</span>: <span class="string">"<span class="subst">$&#123;project.ext.baseName&#125;</span>"</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>ext</code>에는 해당 모듈의 이름과 버전 정보가 들어가게 된다. 클라이언트와 QA가 원하는 값은 저 버전 정보이다.</li><li>모듈을 추가만 해주면 끝이다. 이제 여러 정보들을 endpoint 로 제공받을 수 있다. 하지만 이번 포스팅에서는 다른 기능들을 알아보는건 스킵하도록 한다. (조금 써보았는데 굉장히 많은 정보들을 제공해주고 있다. 나중에 좀 더 깊게 살펴보는게 좋겠다.)</li><li><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#howto-build-info" rel="external nofollow noopener noreferrer" target="_blank">buildInfo</a> 값을 넣어주면 gradle 로 빌드할 때 기본적인 빌드 정보들을 <code>build-info.properties</code> 파일 안에 적어주는데 추가적인 정보들을 넣어줄 수 있다.</li></ol><p>이제 빌드를 해서 결과값을 살펴보자. <code>build/resources/main/META-INF/build-info.properties</code> 안에 buildInfo의 기본적인 값들과 추가적으로 기술해준 정보들이 아래와 같이 들어가있다.</p><p><code>build-info.properties</code></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Properties</span></span><br><span class="line"><span class="comment">#Sat Mar 24 16:17:58 KST 2018</span></span><br><span class="line">build.<span class="attribute">time</span>=2018-03-24T16\:17\:58+0900</span><br><span class="line">build.<span class="attribute">artifact</span>=api</span><br><span class="line">build.<span class="attribute">group</span>=teddy</span><br><span class="line">build.<span class="attribute">name</span>=api</span><br><span class="line">build.<span class="attribute">version</span>=9.2.8</span><br></pre></td></tr></table></figure><h3><span id="dev-서버에-배포된-버전은-928입니다">dev 서버에 배포된 버전은 9.2.8입니다.</span></h3><p>값이 잘 들어와있음을 확인했다. 이제 actuator에서 제공하는 endpoint <code>info</code>로 이 값들을 확인할 수 있다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> &gt; curl localhost:8080/info</span></span><br><span class="line">&#123;</span><br><span class="line">"build":&#123;</span><br><span class="line">"version":"9.2.8-SNAPSHOT",</span><br><span class="line">"artifact":"teddy",</span><br><span class="line">"name":"api",</span><br><span class="line">"group":"com.nevercaution",</span><br><span class="line">"time":1521877296000</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>설정과 적용이 완료 되었다. 이제 어느 누가 서버의 버전을 묻는다면 버벅이지 말고 자신있게 버전을 알려주도록 하자.</p><h2><span id="결론">결론</span></h2><p>요즘 <a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#production-ready" rel="external nofollow noopener noreferrer" target="_blank">spring boot reference guide</a> 를 읽고 있는데 개인적인 느낌으로는 <a href="https://docs.djangoproject.com/en/2.0/" rel="external nofollow noopener noreferrer" target="_blank">django document</a> 보다 훨씬 상세하고 직관적으로 문서를 작성해놓았다고 생각한다. <s>django문서보면서 추상적인 표현에 적잖이 당황했었다</s><br>그리고 spring boot starter 에 많은 기능들이 있어 따로 작업해야 하는 부분이 줄어들었고 적용도 간단히 된다.<br>조금 뜬금없는 생각이지만 spring boot 모듈을 한번쯤은 만들어 봐야 겠다는 생각이 들었다.</p>]]></content>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> gradle </tag>
            
            <tag> spring-boot-actuator </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring-boot 에서 Elasticsearch java rest client 사용하기</title>
      <link href="/2018/03/15/elasticsearch-rest-client/"/>
      <url>/2018/03/15/elasticsearch-rest-client/</url>
      <content type="html"><![CDATA[<h3><span id="elasticsearch-버전을-올려야-한다">elasticsearch 버전을 올려야 한다.</span></h3><p>검색 서비스를 개선하면서 사내에서 elasticsearch 를 사용하고 있다.<br>처음에 사용했던 버전은 개발 당시의 가장 최근 버전인 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.1/index.html" rel="external nofollow noopener noreferrer" target="_blank">elasticsearch 5.1.1</a> 버전이다.<br>spring boot 에 연동했는데 <a href="https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-data-elasticsearch" rel="external nofollow noopener noreferrer" target="_blank">spring-boot-data-elasticsearch-starter</a> 는 (글을 작성하는) 아직까지도 2.x 버전만 지원하고 있어 직접 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.1/client.html" rel="external nofollow noopener noreferrer" target="_blank">client</a> 를 붙이기로 했다.</p><p>개인적인 생각으로는 나중에 개발이 되어질 spring-boot-data-elasticsearch-starter 로 재구현해도 되긴 하겠지만 elasticsearch를 사용하면서 느낀점은 굳이 starter를 사용할 필요는 없다고 생각한다.<br>repository와 model로 나뉘어 orm처럼 사용하면 편하기야 할테지만 직접 쿼리를 만들면서 튜닝하는 부분이 재미있기도 하고 좀 더 세세하게 만질 수 있다고 생각하기 때문이다.</p><p>elasticsearch 는 버전업이 빠른 편이다. 6.x 도 꾸준히 올라가는 추세고 곧있으면 7.x 이 나오고 9.x 까지 로드맵이 그려져 있다. 다행히 5.1.x 버전대에서 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/5.6/rolling-upgrades.html" rel="external nofollow noopener noreferrer" target="_blank">rolling upgrade</a> 가 가능하기 때문에 5.x 의 마지막 버전인 5.6.8 까지 따라 올라가야 겠다고 생각했다. 그러다가 문득 <a href="https://www.elastic.co/blog/state-of-the-official-elasticsearch-java-clients" rel="external nofollow noopener noreferrer" target="_blank">State of the official Elasticsearch Java Clients</a> 라는 포스팅을 보게 되었다. 처음에 java client 를 붙이려면 공식 문서에서는 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.1/transport-client.html" rel="external nofollow noopener noreferrer" target="_blank">transport client</a> 로 연동하도록 안내한다. 하지만 위의 포스팅의 여러 문제점으로 인해 앞으로는 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/6.2/client.html" rel="external nofollow noopener noreferrer" target="_blank">Rest client 를 사용하도록 권장하고 있다.</a></p><p>Java Rest Client 는 두가지 방식이 있다.</p><ul><li>Java Low Level REST Client</li><li>Java High Level REST Client</li></ul><p>low level 에서는 요청을 직접 만들어서 호출하는 방식인데, 나는 high level로 작업하기로 했다.<br>(참고로 rest client는 5.6부터 제공되었다.)</p><h3><span id="서론이-조금-길었다">서론이 조금 길었다.</span></h3><p>내가 elasticsearch 버전을 올리기로 생각한 이유는 <a href="https://www.elastic.co/support/eol" rel="external nofollow noopener noreferrer" target="_blank">elasticsearch 기술 지원</a> 때문이다.<br>내가 사용하고 있는 5.1.x 는 2018-06-08 까지만 공식지원을 하고 있다.<br>물론 공식 지원이 끊기더라도 검색 서비스를 구동함에는 큰 지장은 없지만, 메이져 버전이 두개 이상 차이가 나게 되었을 때 버전을 올려야 하는 상황이 오면 rolling upgrade도  사용할 수 없기 때문에 이참에 6.2 로 올라가기로 마음먹었다. 현재 버전에서 한번에 올라가는건 안되기 때문에 다음과 같이 버전올림 순서를 정하기로 했다.</p><h2><span id="업데이트-순서">업데이트 순서</span></h2><ol><li>elasticsearch 5.1.1 -&gt; 5.6.8 로 rolling upgrade</li><li>spring-boot elasticsearch java client 5.1.1 -&gt; 5.6.8 로 업데이트 후 배포</li><li>elasticsearch 5.6.8 -&gt; 6.2.2 로 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-upgrade.html" rel="external nofollow noopener noreferrer" target="_blank">rolling upgrade</a></li><li>spring-boot elasticsearch java client 5.6.8 -&gt; 6.2.2 로 업데이트 후 배포</li></ol><p><a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/5.6/java-rest-high-compatibility.html" rel="external nofollow noopener noreferrer" target="_blank">메이져 버전별로의 호환성</a>에 따라 5.x 버전끼리는 문제없이 통신을 할 수 있다. 물론 6.x 끼리의 버전도 문제가 없었는데, 테스트 결과 5.6.8 에서 6.2.2 도 호출이 가능했다.<br>클라이언트를 보니 모든 기능을 사용할 수 있지는 않고 부분적인 기능들만 사용가능할 것으로 보인다. 그리고 상위 버전 호환은 괜찮아도 하위 버전 호환은 기능이 구현되지 않을 가능성이 있어 문제의 여지가 있다.</p><h3><span id="rolling-upgrade">rolling upgrade</span></h3><p>현재 사용하고 있는 rolling upgrade 스크립트이다. 구글링 해보니 좀 더 유려한 스크립트 들이 많이 있는데 나는 간단한 동작들만 사용하는 중이다.</p><p>일단 구동중인 es를 내린다.<br><code>shut_down.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># disable shard allocation</span></span><br><span class="line">curl -XPUT <span class="string">'localhost:9200/_cluster/settings?pretty=true'</span> -d <span class="string">'&#123;</span></span><br><span class="line"><span class="string">    "transient" : &#123;</span></span><br><span class="line"><span class="string">        "cluster.routing.allocation.enable" : "none"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># shutdown</span></span><br><span class="line">sudo service elasticsearch stop</span><br></pre></td></tr></table></figure><p>정상적으로 내려간 것을 확인한 후 elasticsearch 버전을 올려 재설치하도록 한다. 그리고 다시 구동시켜 주자.</p><p><code>start.sh</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line">sudo service elasticsearch start</span><br><span class="line"></span><br><span class="line">STATUS=<span class="string">""</span></span><br><span class="line"><span class="keyword">while</span> ! [[ <span class="string">"<span class="variable">$STATUS</span>"</span> =~ (\<span class="string">"tagline\" : \"You Know, for Search\") ]];</span></span><br><span class="line"><span class="string">do</span></span><br><span class="line"><span class="string">    echo "</span>fetching http://localhost:9200<span class="string">"</span></span><br><span class="line"><span class="string">    STATUS=`curl -sS -XGET http://localhost:9200`</span></span><br><span class="line"><span class="string">    sleep 1</span></span><br><span class="line"><span class="string">done</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">curl -XPUT 'localhost:9200/_cluster/settings?pretty=true' -d '&#123;</span></span><br><span class="line"><span class="string">    "</span>transient<span class="string">" : &#123;</span></span><br><span class="line"><span class="string">        "</span>cluster.routing.allocation.enable<span class="string">" : "</span>all<span class="string">"</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><p>자 이제 버전도 올렸으니 client 를 변경해보도록 하자.</p><h2><span id="client-에서-rest-client">client 에서 rest client</span></h2><p>위에서 설명한 것과 같이 앞으로는 rest client 를 써야만 하는 시점이 온다.<br>지금 당장은 바꾸지 않아도 되지만 (완성이 되지 않아 할 수도 없지만) 어떻게 바뀌는지 느낌만 살펴보자.<br>기존에 transport layer로 붙는 client를 rest client로 변경하는 작업을 해보자. 일단 설정부터 변경해야 한다.</p><h3><span id="setting">setting</span></h3><p><code>build.gradle</code></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'org.elasticsearch:elasticsearch:6.2.2'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'org.elasticsearch.client:elasticsearch-rest-high-level-client:6.2.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 기존에 붙었던 <code>9300</code>포트가 아닌 <code>9200</code>포트로 접속해야 한다.<br><code>application.yml</code></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">elasticsearch:</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">host1.com,</span> <span class="string">host2.com</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">9200</span></span><br></pre></td></tr></table></figure><h3><span id="configuration">configuration</span></h3><p>설정파일을 고쳤으면 configuration쪽을 손봐주도록 하자.<br>기존의 config와 비교를 해보면 다음과 같다.</p><p><code>기존 ElascitsearchConfig.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;'$&#123;elasticsearch.hosts&#125;'.split(',')&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hosts;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;elasticsearch.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Client <span class="title">client</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Settings settings = Settings.builder()</span><br><span class="line">                .put(<span class="string">"client.transport.sniff"</span>, <span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        PreBuiltTransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings);</span><br><span class="line">        <span class="keyword">for</span>(String host : hosts) &#123;</span><br><span class="line">            InetSocketTransportAddress item = <span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(host), port);</span><br><span class="line">            client.addTransportAddresses(item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>변경된 ElascitsearchConfig.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticsearchConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"#&#123;'$&#123;elasticsearch.hosts&#125;'.split(',')&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hosts;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;elasticsearch.port&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">getRestClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;HttpHost&gt; hostList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String host : hosts) &#123;</span><br><span class="line">            hostList.add(<span class="keyword">new</span> HttpHost(host, port, <span class="string">"http"</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RestClientBuilder builder = RestClient.builder(hostList.toArray(<span class="keyword">new</span> HttpHost[hostList.size()]));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestHighLevelClient(builder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3><span id="service">service</span></h3><p>약간씩 달라진 부분들을 살펴보자. 큰틀은 변경되진 않았고 호출하는 클래스나 메소드들이 조금씩 변경되었다.<br>개인 적인 느낌으로는 각 클래스별로 역할이 좀 더 충실해졌다고 생각이 들었다.</p><p><code>create</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// before</span></span><br><span class="line">Client client;</span><br><span class="line">IndicesAdminClient adminClient = client.admin().indices();</span><br><span class="line">CreateIndexResponse createIndexResponse = adminClient.prepareCreate(<span class="string">"index_name"</span>)</span><br><span class="line">            .setSettings(seriesSettings())</span><br><span class="line">            .addMapping(<span class="string">"type name"</span>, seriesIndex()).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">RestHighLevelClient client;</span><br><span class="line">CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">"index_name"</span>);</span><br><span class="line">request.settings(seriesSettings(), XContentType.JSON);</span><br><span class="line">request.mapping(<span class="string">"type_name"</span>, seriesIndex(), XContentType.JSON);</span><br><span class="line">client.indices().create(request);</span><br></pre></td></tr></table></figure><p><code>search query</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common</span></span><br><span class="line">QueryBuilder qb = QueryBuilders.matchQuery(<span class="string">"text"</span>, text);</span><br><span class="line"></span><br><span class="line"><span class="comment">// before</span></span><br><span class="line">Client client;</span><br><span class="line">SearchResponse response = client.prepareSearch(<span class="string">"index_name"</span>).setTypes(<span class="string">"type_name"</span>).setQuery(qb).get();</span><br><span class="line"></span><br><span class="line"><span class="comment">// after</span></span><br><span class="line">RestHighLevelClient client;</span><br><span class="line">SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder().query(qb);</span><br><span class="line">SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">"index_name"</span>).types(<span class="string">"type_name"</span>).source(searchSourceBuilder);</span><br><span class="line">SearchResponse response = client.search(searchRequest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// common</span></span><br><span class="line">response.getHits().forEach(item -&gt; &#123;</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>간단하게 index 를 만들고 검색하는 부분까지의 메소드들을 보았다. 나는 여기에 추가로 alias, exists, multi_search 등을 사용하고 있지만 아직까지 6.2.x 에는 해당 메소드가 없다. 어떻게든 해보려고 엔진소스를 들어가서 한참을 살펴보다가 혹시나 해서 master 브랜치를 받아보니 해당 메소드들이 있더라… (현재 master 브랜치의 버전은 7.0.0-alpha1 이다.)</p><h2><span id="결론">결론</span></h2><p>미리 적용을 해놓을까 해서 버전별로 소스를 살펴 보았지만 아직까지 모든 메소드들이 구현되어 있지 않기도 하고 <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/5.6/client.html" rel="external nofollow noopener noreferrer" target="_blank">java client가 없어지려면 8.0 까지 올라가야 하니</a> 아직은 조금 여유가 있어보인다.<br>그래도 버전이 올라가는 속도를 보면 7.0 메이져 버전이 나오고 rest client가 완성이 되었을 때 슬슬 적용하면 될 것 같다. <s>세수하러 왔다가 물만 먹고 가는 느낌</s></p>]]></content>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> elasticsearch </tag>
            
            <tag> restclient </tag>
            
            <tag> javaclient </tag>
            
            <tag> transportlyer </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring boot 에서 jsp view 만들기 (feat freemarker)</title>
      <link href="/2018/02/22/spring-boot-jsp/"/>
      <url>/2018/02/22/spring-boot-jsp/</url>
      <content type="html"><![CDATA[<h3><span id="view를-추가해야한다">view를 추가해야한다.</span></h3><p>spring 을 사용하다가 spring boot 로 넘어오면서 front, back 을 나누어서 백단은 나름 Restful 하게 해서 api 콜만 처리하는 방식으로 변경하는 중이다.(front 는 react로 구성하는 중이다.) 그래서 spring boot 에서는 따로 view 처리해야할 일이 없었는데 기존에 spring 에서 view 처리를 해주는 요청을 가져와야 할일이 생겼다.<br>하지만 찾아보니 기존에 spring 에서 하던 방법으로는 안될 것 같다.<br>왜냐하면 <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-developing-web-applications.html#boot-features-jsp-limitations" rel="external nofollow noopener noreferrer" target="_blank">spring boot 에서는 jar 로 사용할 때는 jsp를 사용할 수 없다고 한다.</a><br>내용을 읽어보니 boot에 내장 tomcat에 하드코딩 패턴때문에 jar형식으로는 webapp내용을 가져올 수 없다고 한다. 그리고 공식적으로 jsp를 지원하지 않는다고 한다. boot에서 밀고 있는 template engine 들이 여러개 있었는데 간단한 view 하나 추가하는데 공수가 많이 들게되면 좋지 않을꺼라 생각해서 jsp로 view 를 구성하는 방법을 시도해보았다.<br>일단 작업을 시작하기 전에 현재 사용하고 있는 버전들을 정리하고 간다.</p><h3><span id="사용하고-있는-버전은-다음과-같다">사용하고 있는 버전은 다음과 같다.</span></h3><ul><li>spring boot 1.5.7</li><li>gradle 4.4</li></ul><h3><span id="나중에는-없어질-view-이지만">나중에는 없어질 view 이지만</span></h3><p>front작업이 react로 완료되면 이 view 는 더이상 필요하지 않다.<br>그래서 나는 최소한의 공수로 기존에 있는 jsp 파일을 사용하여 가볍게 포팅만 하고자 했다.</p><hr><h2><span id="1차-시도">1차 시도</span></h2><p>spring boot 에서 jsp view를 사용하기 위해 spring에서 구성하는 방법과 추가적으로 필요한 설정들을 해주었다.<br>spring boot 의 내장 tomcat에는 jsp parser가 없기 때문에 의존 패키지를 추가해주어야 한다.</p><ul><li>build.gradle</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">derendencies &#123;</span><br><span class="line">    compile(<span class="string">'javax.servlet:jstl'</span>)</span><br><span class="line">    compile(<span class="string">"org.apache.tomcat.embed:tomcat-embed-jasper"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 구조는 아래와 같이 구성했다. main밑에 webapp폴더를 추가해서 jsp파일을 추가해준다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build.gradle</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── com</span><br><span class="line">    │   │       └── example</span><br><span class="line">    │   │           └── demo</span><br><span class="line">    │   │               ├── DemoApplication.java</span><br><span class="line">    │   │               └── MyController.java</span><br><span class="line">    │   ├── resources</span><br><span class="line">    │   │   └── application.properties</span><br><span class="line">    │   └── webapp</span><br><span class="line">    │       └── WEB-INF</span><br><span class="line">    │           └── jsp</span><br><span class="line">    │               └── index.jsp</span><br><span class="line">    └── <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>spring boot 는 webapp의 위치를 모르기 때문에 설정파일에 경로를 명시해주어야 한다.</p><ul><li>application.properties</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spring.mvc.view.prefix=/WEB-INF/jsp/</span><br><span class="line">spring.mvc.view.suffix=.jsp</span><br></pre></td></tr></table></figure><p>설정은 다했다. 이제 controller에서 view를 호출해보자.</p><ul><li>MyController.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ModelAndView view = <span class="keyword">new</span> ModelAndView(<span class="string">"index"</span>);</span><br><span class="line">        view.addObject(<span class="string">"text"</span>, <span class="string">"world"</span>);</span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>설정파일에서 prefix, suffix를 적어주었기 때문에 view이름은 파일이름만 넣어주면 된다.</p><ul><li>index.jsp</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        hello $&#123;text&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>이제 bootRun 을 하면 build 를 하고 테스트를 해볼 수 있다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew clean bootRun</span><br><span class="line">:compileJava </span><br><span class="line">:processResources </span><br><span class="line">:classes </span><br><span class="line">:findMainClass</span><br><span class="line">:bootRun</span><br></pre></td></tr></table></figure><ul><li>localhost:8080/</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello world</span><br><span class="line"></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>build 명령어로 jar파일을 만들어 보자.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ./gradlew clean build</span><br><span class="line">:compileJava </span><br><span class="line">:processResources </span><br><span class="line">:classes </span><br><span class="line">:findMainClass</span><br><span class="line">:jar</span><br><span class="line">:bootRepackage</span><br><span class="line">:assemble</span><br><span class="line">:compileTestJava </span><br><span class="line">:processTestResources NO-SOURCE</span><br><span class="line">:testClasses </span><br><span class="line">:<span class="built_in">test</span> </span><br><span class="line">:check </span><br><span class="line">:build</span><br><span class="line"></span><br><span class="line">BUILD SUCCESSFUL</span><br><span class="line"></span><br><span class="line">Total time: 1.494 secs</span><br></pre></td></tr></table></figure><p><code>./build/libs/testGradle-0.0.1-SNAPSHOT.jar</code> 에 jar가 만들어졌다. 이걸로 직접 띄워서 호출해보자.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java -jar build/libs/testGradle-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure><p>잘 뜨는 것을 확인 할 수 있다. 그런데 더이상 boot진영에서도 jsp파일을 그대로 쓰는걸 권장하고 있지 않으니 그냥 추천해주는 template engine로 넘어가야겠다는 생각이 들었다.</p><h2><span id="2차-시도">2차 시도</span></h2><p>찾아보니 정말 <a href="%22http://www.baeldung.com/spring-template-engines%22">여러가지 template engine</a>들이 있었다. 곰곰히 찾아보다 간단해 보이는 <a href="%22https://freemarker.apache.org/%22">Free Marker</a>를 써보기로 했다.<br>설정을 추가해주는 것도 간단하다. 추가를 해보자.</p><ul><li>build.gradle</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    compile(<span class="string">'org.springframework.boot:spring-boot-starter-freemarker'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>그리고 jsp로 인한 설정들을 모두 제거해준다.</p><ul><li>application.properties</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#spring.mvc.view.prefix=/WEB-INF/jsp/</span></span><br><span class="line"><span class="comment">#spring.mvc.view.suffix=.jsp</span></span><br></pre></td></tr></table></figure><p>그리고 free marker 의 확장자는 <code>.ftl</code> 이다. 기본적인 파일 위치는 <code>resources/templates/</code> 이다.<br>이에 따라 파일명을 수정해주고 이동까지 하면 아래와 같이 된다.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── build.gradle</span><br><span class="line">├── gradle</span><br><span class="line">│   └── wrapper</span><br><span class="line">│       ├── gradle-wrapper.jar</span><br><span class="line">│       └── gradle-wrapper.properties</span><br><span class="line">├── gradlew</span><br><span class="line">├── gradlew.bat</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── com</span><br><span class="line">    │   │       └── example</span><br><span class="line">    │   │           └── demo</span><br><span class="line">    │   │               ├── DemoApplication.java</span><br><span class="line">    │   │               └── MyController.java</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       ├── application.properties</span><br><span class="line">    │       └── templates</span><br><span class="line">    │           └── index.ftl</span><br><span class="line">    └── <span class="built_in">test</span></span><br><span class="line">        └── java</span><br><span class="line">            └── com</span><br><span class="line">                └── example</span><br><span class="line">                    └── demo</span><br><span class="line">                        └── DemoApplicationTests.java</span><br></pre></td></tr></table></figure><p>위와 같이 설정하고 빌드를 하고 jar파일을 띄워주면 1차시도와 동일한 결과가 나온다.<br>처음에는 jsp파일을 가지고 어떻게든 띄워보려고 노력했지만 다른 template engine을 보니 복잡한 jsp파일이 아니라면 굳이 사용하지 않아도 될거라는 생각이 들었다.</p><h2><span id="결론">결론</span></h2><p>아무래도 이제는 spring boot를 사용하면서 jsp를 사용하기는 어려울듯 싶다. 나도 결국에는 다른 template engine을 사용했는데 설정부터 적용이 너무 편해진 느낌.<br>각 template engine마다 문법이 조금 달라서 개인의 기호에 맞게 써야겠다만…(예전에 node를 할 때 <a href="%22https://www.npmjs.com/package/jade%22">jade</a>같은 경우엔 적잖은 충격을 받았었다.)<br>아무래도 아직까지는 html친화적인 문법이 조금은 더 익숙한 느낌이다.</p>]]></content>
      
      
        <tags>
            
            <tag> springboot </tag>
            
            <tag> gradle </tag>
            
            <tag> jsp </tag>
            
            <tag> freemarker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django orm standalone feat(docker)</title>
      <link href="/2017/06/23/django-orm-standalone/"/>
      <url>/2017/06/23/django-orm-standalone/</url>
      <content type="html"><![CDATA[<p>필요에 의해서 배치 작업을 만들어야 했다.<br>간단하게 python으로 만들까 했는데, 단순 cursor로 사용하지 않고 django orm 으로 만들어 보고 싶은 생각이 들었다.<br>이미 작업하고 있는 django project 가 있었고, 그 안에서 사용하는 모델들을 사용해서 스크립트들을 만들면 좋겠다 생각이 들었다.<br>이미 django 구조에 익숙한 사람이라면 편하게 사용할 수 있을거라 생각했고, 관리가 용이하다는 장점이 있다.</p><h3><span id="해야할-일은">해야할 일은…</span></h3><ul><li>mysql, mongo에서 데이터를 주기적으로 가져온다.</li><li>데이터를 가공해서 다시 mysql이나 mongo로 데이터를 주기적으로 쌓아준다.</li><li>여러 서버의 상황에 맞게 대응을 해야한다.(real, sandbox, test등등)</li></ul><p>이미 사내에서 사용하고 있는 훌륭한 배치 스크립트 뭉치가 있다. 이 스크립트는 cursor를 통해서 mysql 데이터를 가져오고 넣는다.<br>물론 cursor로 쿼리를 작성해도 되지만 django-orm을 이용해서 이 작업을 조금 더 수월하게 할 수는 없을까? 하는 생각에 django template 를 사용하지 않고 orm 만 사용할 수 있는 프로젝트를 만들어보기로 했다.</p><h3><span id="django-orm-standalone으로-가자">django-orm standalone으로 가자</span></h3><p>일단 간단한 django 프로젝트를 하나만든다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> django-admin startproject django-orm</span></span><br></pre></td></tr></table></figure><p>설정과 최소한의 파일들을 제외하고 모두 제거해버리자. 구조는 아래와 같다.</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── build.sh</span><br><span class="line">├── db</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── models.py</span><br><span class="line">├── manage.py</span><br><span class="line">├── requirements.txt</span><br><span class="line">├── run.sh</span><br><span class="line">├── scripts</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   └── test.py</span><br><span class="line">└── settings.py</span><br></pre></td></tr></table></figure><ol><li>requirements.txt : 스크립트를 수행할 떄 필요한 모듈등을 기술해준다.</li><li><a href="http://manage.py" rel="external nofollow noopener noreferrer" target="_blank">manage.py</a> : django-extension의 runscript 나 shell 기능을 사용할 수 있도록 한다.</li><li><a href="http://settings.py" rel="external nofollow noopener noreferrer" target="_blank">settings.py</a> : 여러 저장소의 접속 환경이나 환경변수들을 선언해준다.</li></ol><p>위의 구조를 뼈대로 필요한 부분을 채워서 사용하기로 한다. requirements.txt를 살펴보자.</p><ul><li>requirements.txt</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Django</span>==<span class="number">1.11</span>.<span class="number">2</span>    </span><br><span class="line"><span class="attr">django-extensions</span>==<span class="number">1.7</span>.<span class="number">9</span>  </span><br><span class="line"><span class="attr">mysqlclient</span>==<span class="number">1.3</span>.<span class="number">10</span>  </span><br><span class="line"><span class="attr">pytz</span>==<span class="number">2017.2</span>  </span><br><span class="line"><span class="attr">six</span>==<span class="number">1.10</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/django-extensions/django-extensions" rel="external nofollow noopener noreferrer" target="_blank">django-extension</a> 을 사용해서 스크립트들을 돌리고, mysql 의 데이터를 사용하기 위해 둘다 설치해주었다. 각자 필요한 부분이 있다면 추가해주면 된다.<br>이번에는 설정파일을 보도록 하자.</p><ul><li><a href="http://settings.py" rel="external nofollow noopener noreferrer" target="_blank">settings.py</a></li></ul><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"># Build paths inside the project like this: os.path.join(BASE_DIR, ...)</span><br><span class="line">BASE_DIR = os.path.dirname(os.path.abspath(__file__))</span><br><span class="line"></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'test'</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">''</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="string">'3306'</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = (</span><br><span class="line">    <span class="string">'db'</span>,</span><br><span class="line">    <span class="string">'django_extensions'</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># SECURITY WARNING: Modify this secret key <span class="keyword">if</span> using <span class="keyword">in</span> production!</span><br><span class="line">SECRET_KEY = <span class="string">'&#123;your_secret_key&#125;'</span></span><br><span class="line"></span><br><span class="line">LANGUAGE_CODE = <span class="string">'en-us'</span></span><br><span class="line"></span><br><span class="line">TIME_ZONE = <span class="string">'Asia/Seoul'</span></span><br><span class="line"></span><br><span class="line">USE_I18N = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">USE_L10N = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">USE_TZ = <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>기본 설정파일에서 DATABASES 부분만 수정해 준 상태이고 model들이 KST로 시간을 붙어여 했기 때문에 타임존 설정을 서울로 바꾸어 주었다.<br>여기에서 로그에 대한 설정이나 다른 저장소에 대한 정보를 적어주면 된다.</p><p>구조를 잡았으니 추가해야할 패키지들을 설치해주도록 한다. 여기서부터는 익히 알고 있는 패턴이므로 간단하게 살펴보자.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install -r requiremwnts.txt</span></span><br></pre></td></tr></table></figure><p>모델은 현재 자신의 db에 있는 테이블을 정의해주고 orm으로 붙기만 하면 된다. 모델을 한번 보자.</p><ul><li><a href="http://model.py" rel="external nofollow noopener noreferrer" target="_blank">model.py</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create your models here.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    id = models.IntegerField(primary_key=<span class="keyword">True</span>)</span><br><span class="line">    name = models.CharField(max_length=<span class="number">11</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        managed = <span class="keyword">False</span></span><br><span class="line">        db_table = <span class="string">'user'</span></span><br></pre></td></tr></table></figure><p>db 설정을 해주었고 필요한 패키지를 설치했고, 모델들을 정의해주었다면 한번 붙어보자.</p><h3><span id="hello-orm">hello orm</span></h3><p>python shell 로 들어가서 모델을 통해 데이터를 가져오면 된다.</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">python</span> manage.<span class="keyword">py</span> <span class="keyword">shell</span></span><br></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">from</span> db.models import User</span><br><span class="line">&gt;&gt;&gt; User.objects.all()</span><br><span class="line">&lt;QuerySet [&lt;User:<span class="built_in"> User </span>object&gt;, &lt;User:<span class="built_in"> User </span>object&gt;, &lt;User:<span class="built_in"> User </span>object&gt;, &lt;User:<span class="built_in"> User </span>object&gt;, &lt;User:<span class="built_in"> User </span>object&gt;]&gt;</span><br></pre></td></tr></table></figure><p>모델을 통해 데이터를 가져올 수 있고, 작업해야할 부분은 스크립트를 만들어서 사용하도록 한다. 기본적인 스크립트를 하나 만들어보자.</p><ul><li><a href="http://test.py" rel="external nofollow noopener noreferrer" target="_blank">test.py</a></li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> db.models import <span class="keyword">User</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def <span class="keyword">run</span><span class="bash">(*script_args):</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">user_list = User.objects.all()</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="keyword">for</span> user <span class="keyword">in</span> user_list:</span></span><br><span class="line"><span class="bash"><span class="built_in">print</span>(<span class="string">'name : '</span>, user.name)</span></span><br></pre></td></tr></table></figure><p>간단하다. 스크립트를 만들었으니 수행해보자. runscript 는 위에서도 언급했지만 django-extension의 기능중 하나이다.</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python manage.py runscript test</span><br><span class="line">name :  <span class="type">teddy</span></span><br><span class="line">name :  <span class="type">canel</span></span><br><span class="line">name :  <span class="type">twght</span></span><br></pre></td></tr></table></figure><p>이제 필요한 스크립트를 만들어서 crontab에 걸어두면 django orm 을 이용해서 스크립트를 사용할 수 있다.<br>여기까지 했으면 간단하게 끝날텐데, 이 배치 스크립트를 여러 환경에 배포하고 돌려야 하는 일이 남아있었다.<br>물론 서버가 많지 않아 git으로 땡기거나 손으로 직접 옮겨도 되지만, 칼을 뽑은 김에 docker image 로 만들어서 써보자. 어렵지 않다.</p><p>Docker iamge 로 만드는 작업은 완전 단순하다. 사용법도 전혀 어렵지 않다. 일단 Dockerfile을 보자.</p><ul><li>Dockerfile</li></ul><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.5</span>-<span class="keyword">onbuild</span></span><br></pre></td></tr></table></figure><p>사족으로 <a href="https://github.com/docker-library/python/blob/9a9021f2134d953165b31d98cacb95aa34076f90/3.5/onbuild/Dockerfile" rel="external nofollow noopener noreferrer" target="_blank">pythpn:3.5-onbuild</a> 에서 하는 일은 아래와 같다.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> THIS DOCKERFILE IS GENERATED VIA "update.sh"</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># PLEASE DO NOT EDIT IT DIRECTLY.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir -p /usr/src/app</span></span><br><span class="line"><span class="bash">WORKDIR /usr/src/app</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ONBUILD COPY requirements.txt /usr/src/app/</span></span><br><span class="line"><span class="bash">ONBUILD RUN pip install --no-cache-dir -r requirements.txt</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ONBUILD COPY . /usr/src/app</span></span><br></pre></td></tr></table></figure><p>이렇게만 써주고 build 하면 끝이다.</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build --<span class="keyword">tag</span> <span class="title">django-orm</span>:<span class="number">0.1</span> .</span><br></pre></td></tr></table></figure><p>이미지를 만들었다면 다음과 같이 생성이 된다.</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY            <span class="keyword">TAG</span>                 <span class="title">IMAGE</span> ID            CREATED             SIZE</span><br><span class="line">django-orm            <span class="number">0.1</span>                 c8a6c10c8233        About an hour ago   <span class="number">715</span> MB</span><br></pre></td></tr></table></figure><p>이 이미지를 사용하기 위해서는 run 명령으로 사용하도록 하자.</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="keyword">run</span><span class="bash"> --name django-orm django-orm python manage.py runscript <span class="built_in">test</span></span></span><br></pre></td></tr></table></figure><h3><span id="docker로-사용할-때-신경써야할-부분이-있다면">docker로 사용할 때 신경써야할 부분이 있다면</span></h3><p>container 내부에서는 host에 바로 접근할 수가 없기 때문에 mysql localhost 를 바라봐야 한다면 localhost 로 명시해주면 안된다.<br>물론 회피 방법은 조금만 구글링해도 나오지만 원칙적으로는 접근을 할 수 없으므로 이 부분을 신경써서 작업해주어야 한다.<br><s>나는 mysql이 다른 서버에 동작하고 있었기 떄문에 별 문제는 없었다.</s></p><h3><span id="결론">결론</span></h3><p>이미 django project 를 구동해본 경험이 있다면 큰 어려움 없이 사용할 수 있을 것이다.<br>물론 해당 프로젝트에서 배치 스크립트를 작성할 수도 있지만, 성격이 맞지 않을 수 있기 때문에 굳이 억지로 넣을 필요는 없다.<br>cursor로 작업하는게 간단하고 편할 수도 있지만, 여러 패키지를 함께 써야하고 여러 db 설정을 바라봐야 한다면 django 의 골격을 그대로 사용하는 방법이 손쉬울 수 있겠다.<br>해당 예제는 <a href="https://github.com/nevercaution/django-orm" rel="external nofollow noopener noreferrer" target="_blank">django-orm standalone</a> 에서 확인할 수 있다.</p>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> django </tag>
            
            <tag> orm </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django에서 SSO하기</title>
      <link href="/2016/05/06/django-sso/"/>
      <url>/2016/05/06/django-sso/</url>
      <content type="html"><![CDATA[<p>회사에서 필요에 의해 <a href="https://ko.wikipedia.org/wiki/%ED%86%B5%ED%95%A9_%EC%9D%B8%EC%A6%9D," title="Single Sign On" rel="external nofollow noopener noreferrer" target="_blank">Single Sign On</a>을 구현해야 할 일이 있었다. 3개의 독립된 사이트가 있었고, 각자 로그인을 따로 해야 한다는 점이 사용자 입장에서는 번거로운 일이 될 수 있다는 이유에서 였다.</p><p>3개의 사이트는 하나의 유저테이블을 바라보고 있었기 때문에 충분히 합당한 이유였다. 하지만 django에서 제공하는 기본 유저 테이블을 사용하지 않기 때문에 찾아봤었던 다른 인증 툴들은 그대로 사용하기 까다로워 보였다. 내가 구현해야 하는 상황에는 몇가지 제약사항이 있었다.</p><ol><li><p>로그인을 시도할 때 기존에 제공되는 auth_user 테이블이 아닌 <u>별도의 user 테이블을 사용하고 있다.</u></p></li><li><p>기존에 제공되는 user 모델을 사용하지 않기 때문에 <u>reatframework 에서 기존에 제공하는 인증방식을 그대로 사용할 수 없었다.</u></p></li><li><p>이미 테이블이 존재하고 <u>django 프로젝트에서 migration 을 할 수 없는 상황이다.</u> 기존에 생성되어 있는 테이블들의 구성을 변경할 수는 있지만 그 과정과 절차가 까다롭고 (회사의 사정에 의해), 외래키를 사용하지 않았기 때문에 모델과 테이블간의 100% 싱크가 맞지 않는 상황이었다.</p></li><li><p>위와 같은 이유로 찾아봤었던 <a href="https://github.com/jbittel/django-mama-cas," title="MamaCas" rel="external nofollow noopener noreferrer" target="_blank">MamaCAS</a> 같은 외부 인증툴을 사용할 수 없었다. (migration을 할 수 없었기에 인증을 위해 별도의 테이블을 생성하기 까다로운 상황이었다.)</p></li></ol><p>3개의 프로젝트들이 출시가 얼마 남지 않은 상황이고, 인증을 위해서 별도의 커다란 작업이 있는 것은 별로 좋은 선택이 아니였다. 물론 외부의 다른 툴들을 이용할 수도 있었지만, 단순 인증을 위해 외부툴을 사용하기엔 부담스러운 부분이 있었고, 볼륨을 크게 잡고 싶지 않았다.</p><p>여러 방법을 찾아보면서 몇가지 아이디어가 나왔었다.</p><ol><li><p><a href="https://redis.io/," title="redis" rel="external nofollow noopener noreferrer" target="_blank">redis</a> 를 이용해서 인증 정보를 저장하는 방식</p></li><li><p><a href="https://jwt.io/," title="jwt" rel="external nofollow noopener noreferrer" target="_blank">jwt</a>를 이용해서 javascript 내부에서 localStorage 에 인증 정보를 저장하는 방식</p></li><li><p>cookie에 저장하는 방식</p></li></ol><p>나는 일단 1번의 redis는 제외하기로 했다. 이미 각각의 프로젝트에서 redis를 사용하고 있었고, 인증을 위해 별도의 redis를 띄우는게 번거롭다고 생각했다. 그리고 2번의 localStorage 방식은 javascript에서 ajax통신을 각 페이지별로 날려 유효한 인증을 판단하는 방식이었는데, django 단에서 각 request마다 헤더에 인증 정보를 넣기가 까다로웠다. (하지만 jwt로 토큰을 암호화 하는건 괜찮은 방법이라 생각했다.) 3번의 cookie 방식은 별도의 작업 없이 구현이 가능했지만 3개의 사이트가 같은 메인 도메인 하에 있어야 가능했었다. 어차피 모든 사이트가 회사 내부에서 사용할 목적으로 만들어 지고 있는 프로젝트 였고 같은 메인 도메인만 사용하면 되었기 때문에 나는 3번째의 방법을 사용하기로 했다.</p><p>서론이 길었지만… 그리하여 jwt와 cookie를 이용해서 sso를 구현해 보기로 했다.</p><p>여러 사이트가 있고 각각 로그인(유저 인증)이 필요하고 기능 마다 해당 유저가 접근할 수 있는(허가) 기능이 필요하다.</p><p>(single sign on 을 하다보니 authentication 과 permission 처리가 필요했다…)</p><p>여러 개의 사이트가 공유하는 유저 정보가 있고, 이 정보로 로그인을 하기 때문에 모든 사이트에서 한번의 로그인을 하면 되는 기능이 필요했다.추가적으로 각 사이트 별로는 각자의 허가 정보가 있으므로 이 정보는 공유하지 않고 각자 구현한다. (템플릿만 제공)</p><p>한마디로 요약하면 쿠키에 암호화된 토큰 정보를 도메인이 같은 사이트들끼리 로그인 정보를 공유를 해서 사용하는 방법이다.</p><h2><span id="예상-시나리오">예상 시나리오</span></h2><p><a href="http://alpha.mysite.com" rel="external nofollow noopener noreferrer" target="_blank">alpha.mysite.com</a>, <a href="http://beta.mysite.com" rel="external nofollow noopener noreferrer" target="_blank">beta.mysite.com</a>, <a href="http://charlie.mysite.com" rel="external nofollow noopener noreferrer" target="_blank">charlie.mysite.com</a> 3개의 사이트가 있다.<br>beta 에서 로그인을 하고 charlie 사이트에 접속할 경우 이미 로그인이 되어 있다.<br>3개의 사이트는 각자 permission 이 따로 존재한다.<br>alpha 에서 로그아웃을 할 경우, 나머지 사이트에서도 모두 로그아웃이 된다.<br>로그인 정보가 만료되었을 경우에도 로그아웃 처리된다.</p><h2><span id="시나리오-순서-별-설명">시나리오 순서 별 설명</span></h2><ol><li>로그인 시 : <u>jwt token</u> 을 발급해서 request cookie에 저장한다. (이 때, <u>cookie</u> 의 domain은 main domain 값을 넣어준다.&lt;<a href="http://mysite.com" rel="external nofollow noopener noreferrer" target="_blank">mysite.com</a>&gt;)</li><li>인증이 필요한 페이지에 접속할 경우<br>rest framework 의 <u>authentication</u> class 에서 cookie 에 저장되어 있는 token 값의 유효성을 검사한다.<br>rest framework 의 <u>permission</u> class 에서 해당 유저가 기능에 접근 허가 여부를 판단한다.</li><li>로그아웃 시 : cookie 의 token 값을 지워준다.</li><li>추가 정보<ul><li>인증에 실패한 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.</li><li>기능 접근 허가가 거부된 경우 : block page 를 표시한다.</li><li>토큰이 만료된 경우 : cookie 값을 삭제하고 login 페이지로 보낸다.</li></ul></li><li>제약사항<ul><li>메인 도메인이 동일해야한다.</li><li>permission 정보는 공유하지 않기 때문에 각자 사이트에서 구현해야 한다.</li></ul></li></ol><h2><span id="환경-설정">환경 설정</span></h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">python</span> 3<span class="selector-class">.4</span><span class="selector-class">.3</span></span><br><span class="line"><span class="selector-tag">django</span> 1<span class="selector-class">.8</span><span class="selector-class">.4</span></span><br><span class="line"><span class="selector-tag">djangorestframework</span> 3<span class="selector-class">.3</span><span class="selector-class">.0</span></span><br></pre></td></tr></table></figure><p>하나씩 시작해보자.</p><h3><span id="패키지-추가하기">패키지 추가하기</span></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> pip install djangorestframework-jwt</span></span><br></pre></td></tr></table></figure><h3><span id="로그인-하기">로그인 하기</span></h3><h4><span id="토큰-생성하기">토큰 생성하기</span></h4><p>유저 정보가 맞을 경우 이 정보를 토대로 jwt token을 생성해준다.<br>jwt_util.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> calendar <span class="keyword">import</span> timegm</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">from</span> rest_framework_jwt.settings <span class="keyword">import</span> api_settings</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> user.models.CustomUser <span class="keyword">import</span> CustomUser</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obtain_token</span><span class="params">(user: CustomUser)</span>:</span></span><br><span class="line">    jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER</span><br><span class="line">    jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER</span><br><span class="line"> </span><br><span class="line">    payload = jwt_payload_handler(user)</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># Include original issued at time for a brand new token,</span></span><br><span class="line">    <span class="comment"># to allow token refresh</span></span><br><span class="line">    <span class="keyword">if</span> api_settings.JWT_ALLOW_REFRESH:</span><br><span class="line">        payload[<span class="string">'orig_iat'</span>] = timegm(</span><br><span class="line">            datetime.utcnow().utctimetuple()</span><br><span class="line">        )</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> jwt_encode_handler(payload)</span><br></pre></td></tr></table></figure><p>jwt 변수들에 대한 자세한 설정은 Rest Framework JWT 에서 확인 할 수 있다. 그리고 default 로 설정된 변수들을 재선언 하고 싶다면 setting 에 해주면 된다.</p><p><a href="http://settings.py" rel="external nofollow noopener noreferrer" target="_blank">settings.py</a></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JWT_AUTH = &#123;</span><br><span class="line">    <span class="string">'JWT_EXPIRATION_DELTA'</span>: datetime.timedelta<span class="comment">(hours=24)</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4><span id="쿠키에-저장하기">쿠키에 저장하기</span></h4><p>사용자가 입력한 아이디와 암호가 맞을 경우 이 정보를 cookie 에 저장을 한다. 저장할 때 domain option 을 main domain(<a href="http://mysite.com" rel="external nofollow noopener noreferrer" target="_blank">mysite.com</a>) 로 설정해준다. domain 설정을 해주지 않을 경우 다른 사이트에서 쿠키정보를 공유할 수 없다.</p><p><a href="http://view.py" rel="external nofollow noopener noreferrer" target="_blank">view.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginView</span><span class="params">(View)</span>:</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> TemplateResponse(request, <span class="string">'account/login.html'</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        username = request.POST.get(<span class="string">'username'</span>)</span><br><span class="line">        password = request.POST.get(<span class="string">'password'</span>)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            admin = CustomUser.objects.get(username=username)</span><br><span class="line">            <span class="comment"># 유저 암호 검사하기.</span></span><br><span class="line">            <span class="keyword">if</span> security.matches_password(password, admin.password):</span><br><span class="line">                <span class="comment"># obtain jwt token</span></span><br><span class="line">                token = obtain_token(admin)</span><br><span class="line"> </span><br><span class="line">                <span class="comment"># set cookie</span></span><br><span class="line">                response = HttpResponseRedirect(reverse(<span class="string">'root'</span>))</span><br><span class="line">                response.set_cookie(key=<span class="string">'token'</span>, value=token, domain=settings.COOKIE_DOMAIN)</span><br><span class="line">                <span class="keyword">return</span> response</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                context = &#123;</span><br><span class="line">                    <span class="string">'error'</span>: <span class="string">'비밀번호가 일치하지 않습니다.'</span></span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">except</span> TAdmin.DoesNotExist:</span><br><span class="line">            context = &#123;</span><br><span class="line">                <span class="string">'error'</span>: <span class="string">'존재하지 않는 ID입니다.'</span></span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> TemplateResponse(request, <span class="string">'account/login.html'</span>, context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>공통으로 사용할 메인 도메인 이름은 각 사이트 마다 통일 해줘야 한다.</p><p><a href="http://settings.py" rel="external nofollow noopener noreferrer" target="_blank">settings.py</a></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">COOKIE_DOMAIN</span> = <span class="string">'mysite.com'</span></span><br></pre></td></tr></table></figure><p>쿠키에 토큰 값을 저장 했으므로 이제 각 사이트에 로그인 되었다고 할 수 있는 첫번 째 단계는 달성했다.</p><h4><span id="페이지-인증정보-확인하기">페이지 인증정보 확인하기</span></h4><p>로그인이 되어 있어야 접근할 수 있는 페이지의 경우 로그인 정보를 확인한 후에 정보를 로드한다. RestFramework 에서 제공하는 APIView 를 사용해서 인증 정보를 확인한다.</p><p><a href="http://view.py" rel="external nofollow noopener noreferrer" target="_blank">view.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    authentication_classes = (CustomAuthentication, )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        redirect_url = <span class="string">"/home"</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponseRedirect(redirect_url)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>여기서 authentication class 를 명시적으로 선언해주었는데, 모든 APIView(인증과 허가가 필요한 페이지의 경우) 에 적용될 수 있도록 settings 에 선언해줄 수 있다.</p><p>(인증 실패나 허가 요청 실패시 처리해줄 수 있는 핸들러도 미리 추가해놓자.)</p><p><a href="http://settings.py" rel="external nofollow noopener noreferrer" target="_blank">settings.py</a></p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    '<span class="attribute">DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class="line">        'common<span class="variable">.utils</span><span class="variable">.authentication</span><span class="variable">.CustomAuthentication</span>',</span><br><span class="line">    ),</span><br><span class="line">    'EXCEPTION_HANDLER': 'common<span class="variable">.utils</span><span class="variable">.custom_exception_handler</span><span class="variable">.custom_exception_handler</span>'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>인증 확인은 쿠키에 저장되어 있는 토큰 정보로 확인한다. 토큰으로 정상적인 유저를 가져올 수 있다면 유효한 유저라고 판단한다.</p><p><a href="http://authentication.py" rel="external nofollow noopener noreferrer" target="_blank">authentication.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> authentication</span><br><span class="line"> </span><br><span class="line"><span class="keyword">from</span> common.utils.jwt_util <span class="keyword">import</span> obtain_user</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomAuthentication</span><span class="params">(authentication.BaseAuthentication)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        쿠키에 저장되어 있는 token 값으로 유저를 가져옵니다. 가져오는 상황에서 예외가 발생할 수 있으며 정상적으로 가져온 경우에는 인증된 유저라고 판단합니다.</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        token = request.COOKIES.get(<span class="string">'token'</span>, <span class="keyword">None</span>)</span><br><span class="line">        user = obtain_user(token)</span><br><span class="line">        <span class="keyword">return</span> (user, <span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><p>쿠키에 저장되어 있는 토큰을 decode 하여 유효한 정보인지를 판단한다.</p><p>jwt_util.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obtain_user</span><span class="params">(token: str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    payload = &#123;'username': 'adm001', 'email': 'test@mysite.com', 'user_id': 1, 'exp': 1462187582&#125;</span></span><br><span class="line"><span class="string">    :param token:</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    jwt_decode_handler = api_settings.JWT_DECODE_HANDLER</span><br><span class="line">    jwt_get_username_from_payload = api_settings.JWT_PAYLOAD_GET_USERNAME_HANDLER</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> token <span class="keyword">or</span> len(token) == <span class="number">0</span>:  <span class="comment"># case1: 토큰을 분실 했을 경우</span></span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">'Invalid token header. Non credentials provided.'</span>)</span><br><span class="line">        <span class="comment"># raise exceptions.AuthenticationFailed(&#123;'error': 'Invalid token header. No credentials provided.'&#125;)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        payload = jwt_decode_handler(token)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">except</span> jwt.ExpiredSignature:  <span class="comment"># case2: 토큰이 만료되었을 경우</span></span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">'Signature has expired.'</span>)</span><br><span class="line">        <span class="comment"># raise exceptions.AuthenticationFailed(&#123;'error': 'Signature has expired.'&#125;)</span></span><br><span class="line">    <span class="keyword">except</span> jwt.DecodeError:  <span class="comment"># case3: 디코드 실패</span></span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">'Error decoding signature.'</span>)</span><br><span class="line">        <span class="comment"># raise exceptions.AuthenticationFailed(&#123;'error': 'Error decoding signature.'&#125;)</span></span><br><span class="line"> </span><br><span class="line">    username = jwt_get_username_from_payload(payload)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> username:  <span class="comment"># case4: payload 가 잘못되어 username을 가져올 수 없는 경우</span></span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">'Invalid payload.'</span>)</span><br><span class="line">        <span class="comment"># raise exceptions.AuthenticationFailed(&#123;'error': 'Invalid payload.'&#125;)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        user = CustomUser.objects.get(username=username)</span><br><span class="line">    <span class="keyword">except</span> CustomUser.DoesNotExist:  <span class="comment"># case5: 해당 유저가 존재하지 않는 경우</span></span><br><span class="line">        <span class="keyword">raise</span> serializers.ValidationError(<span class="string">"User doesn't exists."</span>)</span><br><span class="line">        <span class="comment"># raise exceptions.AuthenticationFailed(&#123;'error': "User doesn't exists."&#125;)</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure><p>여러 이유로 인증에 실패할 경우엔 인증 실패 예외가 발생하게 되는데 이는 따로 핸들러로 처리해주어야 한다. (에러 정보는 response.data 에 담겨온다.)<br>(여기서는 인증 실패 예외가 발생할 경우 쿠키에 저장되어 있는 토큰값을 지워버리고 로그인 페이지로 보내버린다.)</p><p>custom_exception_handler.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.core.urlresolvers <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_exception_handler</span><span class="params">(exc, context)</span>:</span></span><br><span class="line">    <span class="comment"># 발생한 exception을 가져온다.</span></span><br><span class="line">    response = exception_handler(exc, context)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="comment"># response_data = response.data['detail']</span></span><br><span class="line">        <span class="comment"># print('response : ', response.__dict__)</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 예외가 발생할 경우엔 token쿠키를 지워준다</span></span><br><span class="line">        response.delete_cookie(<span class="string">'token'</span>, domain=settings.COOKIE_DOMAIN)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'login'</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><h4><span id="페이지-접근-허가-정보-확인하기">페이지 접근 허가 정보 확인하기</span></h4><p>접근하고자 하는 페이지가 각 유저별로 인증 정보가 필요하다면 유저의 인증 정보를 확인할 수 있어야 한다.</p><p><a href="http://permission.py" rel="external nofollow noopener noreferrer" target="_blank">permission.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.permissions <span class="keyword">import</span> BasePermission</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPermission</span><span class="params">(BasePermission)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="comment"># <span class="doctag">TODO:</span> do something</span></span><br><span class="line">        print(<span class="string">'CustomPermission user : '</span>, request.user)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>(현재는 어떤 허가 정보도 판단하지 않지만 이 부분에서 유저 정보를 가지고 해당 페이지에 대한 허가 정보를 판단해서 boolean 값으로 반환해준다. True일 경우 허가된 경우고 False일 경우엔 허가되지 않는 유저이다.)</p><p>APIView 에서 허가 정보도 명시적으로 선언해서 확인할 수 있다.</p><p><a href="http://view.py" rel="external nofollow noopener noreferrer" target="_blank">view.py</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootView</span><span class="params">(APIView)</span>:</span></span><br><span class="line">    authentication_classes = (CustomAuthentication, )</span><br><span class="line">    permission_classes = (CustomPermission, )</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :param request:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        redirect_url = <span class="string">"/home"</span></span><br><span class="line">        <span class="keyword">return</span> HttpResponseRedirect(redirect_url)</span><br></pre></td></tr></table></figure><p>마찬가지로 모든 APIView 에서 허가 정보를 확인해야 한다면 settings 에 설정해줄 수 있다. 좀 전에 인증 정보를 작성한 부분에 추가해주자.</p><p><a href="http://settings.py" rel="external nofollow noopener noreferrer" target="_blank">settings.py</a></p><figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    '<span class="attribute">DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class="line">        'common<span class="variable">.utils</span><span class="variable">.authentication</span><span class="variable">.CustomAuthentication</span>',</span><br><span class="line">    ),</span><br><span class="line">    'DEFAULT_PERMISSION_CLASSES': (</span><br><span class="line">        'common<span class="variable">.utils</span><span class="variable">.permission</span><span class="variable">.CustomPermission</span>',</span><br><span class="line">    ),</span><br><span class="line">    'EXCEPTION_HANDLER': 'common<span class="variable">.utils</span><span class="variable">.custom_exception_handler</span><span class="variable">.custom_exception_handler</span>'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>허가 요청에 대한 부분이 추가되었으므로 예외 처리 핸들러에서 이 부분에 대한 처리도 추가해줘야 한다. 요청이 실패할 경우 403 에러가 발생하는데 이 부분에 대한 처리를 해준다.</p><p>custom_exception_handler.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.conf <span class="keyword">import</span> settings</span><br><span class="line"><span class="keyword">from</span> django.core.urlresolvers <span class="keyword">import</span> reverse</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> status</span><br><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> exception_handler</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">custom_exception_handler</span><span class="params">(exc, context)</span>:</span></span><br><span class="line">    <span class="comment"># 발생한 exception을 가져온다.</span></span><br><span class="line">    response = exception_handler(exc, context)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> response <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="comment"># response_data = response.data['detail']</span></span><br><span class="line">        <span class="comment"># print('response : ', response.__dict__)</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment"># permission 이 안되는 경우엔 block page 로 넘겨준다.</span></span><br><span class="line">        <span class="keyword">if</span> response.status_code == status.HTTP_403_FORBIDDEN:</span><br><span class="line">            <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'block'</span>))</span><br><span class="line"> </span><br><span class="line">        <span class="comment"># 예외가 발생할 경우엔 token쿠키를 지워준다</span></span><br><span class="line">        response.delete_cookie(<span class="string">'token'</span>, domain=settings.COOKIE_DOMAIN)</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">'login'</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p>인증 실패인 경우에는 쿠키에서 토큰 정보를 삭제하고<br>로그인 페이지로 보내버리고,<br>허가 요청 거부일 경우에는 block 페이지로 보내버렸는데,<br>이 부분은 각 사이트의 상황에 맞게 처리해주면 된다.</p><h4><span id="로그아웃-하기">로그아웃 하기</span></h4><p>로그아웃은 간단하다. 단지 쿠키에 저장되어 있는 토큰 값을 지워버리면 되기 때문이다.</p><p><a href="http://view.py" rel="external nofollow noopener noreferrer" target="_blank">view.py</a></p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogoutView</span>(<span class="title">View</span>):</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(<span class="keyword">self</span>, request)</span></span><span class="symbol">:</span></span><br><span class="line">        response = HttpResponseRedirect(reverse(<span class="string">'login'</span>))</span><br><span class="line">        response.delete_cookie(<span class="string">'token'</span>, domain=settings.COOKIE_DOMAIN)</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><h4><span id="요약">요약</span></h4><p>지금까지 추가된 파일들과 클래스를 정리하자면 다음과 같다.</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">common/utils/custom_exception_handler.py</span><br><span class="line">    -<span class="ruby"> custom_exception_handler</span></span><br><span class="line"><span class="ruby">common/utils/authentication.py</span></span><br><span class="line"><span class="ruby">    - CustomAuthentication</span></span><br><span class="line"><span class="ruby">common/utils/permission.py</span></span><br><span class="line"><span class="ruby">    - CustomerPermission</span></span><br><span class="line"><span class="ruby">common/utils/jwt_util.py</span></span><br><span class="line"><span class="ruby">    - obtain_token</span></span><br><span class="line"><span class="ruby">    - obtain_user</span></span><br></pre></td></tr></table></figure><p>여기까지 따라왔다면 sso를 완성 할 수 있다. 하나의 사이트에서 동작하는지 여부를 검사하고 싶다면 hosts 에 도메인을 추가해서 테스트 해보자.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/hosts</span></span><br></pre></td></tr></table></figure><p>/etc/hosts</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span>   <span class="selector-tag">alpha</span><span class="selector-class">.mysite</span><span class="selector-class">.com</span></span><br><span class="line">127<span class="selector-class">.0</span><span class="selector-class">.0</span><span class="selector-class">.1</span>   <span class="selector-tag">beta</span><span class="selector-class">.mysite</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure><p>위와 같이 추가하고 테스트를 해볼 수 있다.</p><h2><span id="결론">결론</span></h2><p>유저의 로그인 검증 후 유저 정보를 jwt 를 이용해서 토큰을 생성한 후, 이 정보는 메인 도메인으로 쿠키에 저장을 한다. 인증이 필요한 페이지의 경우 cookie 에 저장되어 있는 토큰으로 인증된 유저인지 여부를 판단한다. 이 때, 이 토큰 값이 유효하지 않을 경우엔 강제로 로그아웃 처리를 한다. jwt 토큰의 만료 시간을 주어 일정 시간이 지나면 로그인이 풀리도록 했다. 메인 도메인 하위의 3개의 사이트중 하나의 사이트에서만 로그인을 하면 나머지 두개의 사이트에서도 로그인이 되어 있다(같은 쿠키의 토큰을 사용하기 때문)</p><h3><span id="추신">추신</span></h3><p>나름 간단하게 기능을 구현하고자 했는데 로그인 정보를 저장하고 그 토큰을 처리하기 위해 여러 처리가 붙었다. 그리고 토큰 값을 만들고 검증하고 이를 인증하는 코드들을 직접 쓰다보니 조금은 번거로운 작업들이 포함되어 있는 건 사실이다… 때로는 오픈소스를 별다른 이해 없이 기능을 사용하기 위해 가져다 쓰는 것 보다 내부 로직을 이해하고 내가 필요한 부분들만 가져다 쓰는 작업을 하면 재미있기도 하고 후에 문제가 생기거나 기능 변경이 생겼을 때 대처가 빠르다. 물론 이런 방식이 정답을 아닐지는 몰라도 덕분에 재미있는 작업을 했다는 점에 만족한다.</p>]]></content>
      
      
        <tags>
            
            <tag> django </tag>
            
            <tag> sso </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django에서 ajax요청하기</title>
      <link href="/2016/03/27/django-ajax/"/>
      <url>/2016/03/27/django-ajax/</url>
      <content type="html"><![CDATA[<p>View에서 get, post요청을 할 때 template단에서 ajax요청을 날려야할 때가 있다.<br>APIVIew, View 두개의 경우를 살펴보자.<br>1.APIView ↔ ajax (post, get)<br>(post의 케이스로 설명을 하였지만 get도 동일한 방식이다.)<br>가장 빈번하게 사용하는 케이스이다. template 에서 버튼을 눌러 요청을 ajax로 날려 결과값을 받아와서 전체 화면을 다시 그리지 않고 필요한 부분만 갱신해줄 수 있다.</p><ul><li>template.html</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: <span class="string">"&#123;% url 'request:url' %&#125;"</span>,</span><br><span class="line">    <span class="built_in">type</span>: <span class="string">'POST'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        <span class="string">'user_id'</span>: user_id</span><br><span class="line">    &#125;,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span> <span class="params">(response)</span></span> &#123;</span><br><span class="line">        // TODO: <span class="keyword">do</span> something.</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">error</span>: <span class="function"><span class="keyword">function</span> <span class="params">(err)</span></span> &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><a href="http://url.py" rel="external nofollow noopener noreferrer" target="_blank">url.py</a></li></ul> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(<span class="string">r'^request/url$'</span>, views.TestView.as_view(), name=<span class="string">'url'</span>),</span><br></pre></td></tr></table></figure><ul><li><a href="http://view.py" rel="external nofollow noopener noreferrer" target="_blank">view.py</a></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestView</span>(<span class="title">APIView</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(<span class="keyword">self</span>, request)</span></span><span class="symbol">:</span></span><br><span class="line">        user_id = request.POST.get(<span class="string">'user_id'</span>)</span><br><span class="line">      <span class="comment"># do something</span></span><br><span class="line">       <span class="keyword">return</span> Response()</span><br></pre></td></tr></table></figure><p>View class를 상속받고 post 메소드로 받는다면 ajax 요청시 csrf 토큰이 없다고 하면서 403에러가 발생한다.<br>이를 해결해주기 위해 APIView를 상속받아서 처리하면 csrf 인증을 피해갈 수 있다.  (피해간다기보단 이미 인증이 되어있는 요청이라고 판단하는 것이지만)<br>이는 APIView의 as_view() 메소드를 보면 알 수 있는데</p><ul><li>api_view.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">as_view</span><span class="params">(cls, **initkwargs)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Store the original class on the view function.</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">    This allows us to discover information about the view when we do URL</span></span><br><span class="line"><span class="string">    reverse lookups.  Used for breadcrumb generation.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(getattr(cls, <span class="string">'queryset'</span>, <span class="keyword">None</span>), models.query.QuerySet):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">force_evaluation</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="keyword">raise</span> RuntimeError(</span><br><span class="line">                <span class="string">'Do not evaluate the `.queryset` attribute directly, '</span></span><br><span class="line">                <span class="string">'as the result will be cached and reused between requests. '</span></span><br><span class="line">                <span class="string">'Use `.all()` or call `.get_queryset()` instead.'</span></span><br><span class="line">            )</span><br><span class="line">        cls.queryset._fetch_all = force_evaluation</span><br><span class="line">        cls.queryset._result_iter = force_evaluation  <span class="comment"># Django &lt;= 1.5</span></span><br><span class="line"> </span><br><span class="line">    view = super(APIView, cls).as_view(**initkwargs)</span><br><span class="line">    view.cls = cls</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># <span class="doctag">Note:</span> session based authentication is explicitly CSRF validated,</span></span><br><span class="line">    <span class="comment"># all other authentication is CSRF exempt.</span></span><br><span class="line">    <span class="keyword">return</span> csrf_exempt(view)</span><br></pre></td></tr></table></figure><p>마지막 라인에 csrf_exempt로 view를 감싸준다. 이는 해당 API요청이 csrf 인증이 되어있다고 명시해주는 것이다.<br>그리고, 내부로 파고 들어가면  APIView에서 authentication_classes = api_settings.DEFAULT_AUTHENTICATION_CLASSES 로 설정이 되어있는데, restframework의 setting을 살펴보면 아래와 같이 정의가 되어있음을 알 수 있다.</p><ul><li>api_settings.py</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: (</span><br><span class="line">    <span class="string">'rest_framework.authentication.SessionAuthentication'</span>,</span><br><span class="line">    <span class="string">'rest_framework.authentication.BasicAuthentication'</span></span><br><span class="line">),</span><br><span class="line">  </span><br><span class="line"><span class="comment"># Authentication</span></span><br><span class="line"><span class="string">'UNAUTHENTICATED_USER'</span>: <span class="string">'django.contrib.auth.models.AnonymousUser'</span>,</span><br><span class="line"><span class="string">'UNAUTHENTICATED_TOKEN'</span>: <span class="keyword">None</span>,</span><br></pre></td></tr></table></figure><p>인증 처리를 rest_framework의 SessionAuthentication으로 하겠다는 내용과 인증 유저를 AnonymousUser 로 설정을 해준다.<br>기존의 인증절차에서 default인증 객체를 검사하게 되는데, 이 때 user객체의 active를 검사할 때 이 객체가 유효하지 않으면 unauthenticated_user로 AnonymousUser객체를 생성하게 된다. 접근 허용 체크를 할 때는 APIView에 정의된 permission class로 체크를 하는데 아래와 같다.</p><ul><li>api_settings.py</li></ul><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">'DEFAULT_PERMISSION_CLASSES': (</span><br><span class="line">    'rest_framework.permissions.AllowAny',</span><br><span class="line">),</span><br></pre></td></tr></table></figure><p>AllowAny Class는 permission요청에 대해 무조건 True를 반환해주므로, APIView의 check_permissions 메소드에서 권한 체크를 할 때 권한이 있다고 판단을 한다.</p><ul><li><a href="http://permissions.py" rel="external nofollow noopener noreferrer" target="_blank">permissions.py</a></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllowAny</span><span class="params">(BasePermission)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Allow any access.</span></span><br><span class="line"><span class="string">    This isn't strictly required, since you could use an empty</span></span><br><span class="line"><span class="string">    permission_classes list, but it's useful because it makes the intention</span></span><br><span class="line"><span class="string">    more explicit.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_permission</span><span class="params">(self, request, view)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>즉, APIView는 기존의 django 에서 체크하고 있는 csrf 공격방어에 대한 인증을 제외하고 따로 인증절차를 진행하게되는데, 인증 유저를 익명유저로 설정하여 유저에 대한 권한검사를 하지 않고 default로 설정이 된 권한체크 클래스로 검사를 한다.<br>AllowAny는 접근 허용여부를 모두 True로 반환하여 접근에 대해 유효하다고 판단하여 csrf토큰 없이 요청 수행이 가능한 것이다.<br>데이터를 모두 처리하고 나서의 응답값은 Response 객체를 반환함으로서 처리한다.</p><p>2.View ↔ ajax (post, get)<br>ajax를 통해 View class에 메소드를 호출하는 경우는 많지는 않았는데, 이유는 굳이 ajax로 호출하지 않아도 할 수 있는 방법들이 있었기 때문이었다.<br>하지만 종종 사용해야할 경우가 있었는데, 이를테면 내부 검색창에서 검색결과를 내부 포멧에 맞게 내용을 채워줘야 하는데 그 template가 별도의 파일로 있는 경우였다.</p><ul><li>template.html</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"#searchFrom"</span>).submit(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user_id = $(<span class="string">"input[name=user_id]"</span>).val();</span><br><span class="line"> </span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        url: <span class="string">"&#123;% url 'user:search' %&#125;"</span>,</span><br><span class="line">        type: <span class="string">"POST"</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">            <span class="string">"csrfmiddlewaretoken"</span>: <span class="string">"\&#123;\&#123; csrf_token \&#125;\&#125;"</span>,</span><br><span class="line">            <span class="string">'user_id'</span>: user_id,</span><br><span class="line">        &#125;,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</span><br><span class="line">            $(<span class="string">'#user_list tbody'</span>).html(response);</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>위의 tempalate에서 입력받은 데이터를 통해 ajax로 호출을 한다. 이 때 호출되는 class는 View를 상속받은 class 이다. form의 submit으로 호출을 한 경우인데 form에 {% csrf_token %}이 들어가있기 때문에 post요청을 날릴 경우엔 403이 떨어진다.(get요청은 안넣어도 상관없다.)이런 경우를 방지하기 위해 data필드에 csrf token 을 넣어준다.<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"csrfmiddlewaretoken"</span>: <span class="string">"&#123;&#123; csrf_token &#125;&#125;"</span>,</span><br></pre></td></tr></table></figure><p>요청을 받고 데이터를 만들고 나면 TemplateResponse를 사용하여 분리되어 생성된 페이지를 반환하게 된다.</p><ul><li><a href="http://view.py" rel="external nofollow noopener noreferrer" target="_blank">view.py</a></li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSearchView</span>(<span class="title">View</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(<span class="keyword">self</span>, request)</span></span><span class="symbol">:</span></span><br><span class="line">        user_id = request.POST.get(<span class="string">'user_id'</span>)</span><br><span class="line">        user_list = service.search_user(user_id)</span><br><span class="line">        context = &#123;</span><br><span class="line">            <span class="string">'user_list'</span>: user_list</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> TemplateResponse(request, <span class="string">'user/user_list.html'</span>, context)</span><br></pre></td></tr></table></figure><p>다시 template에서는 넘어온 html덩어리를 미리 정의해둔 위치에 그대로 붙여줌으로서 화면을 다시 그리지 않고, 필요한 부분만 넣어줄 수 있다.<br>(APIView등을 통해 데이터만 받아와 다시 그리는 방법도 있지만 성격이 맞지 않는다고 생각하였고, 일반 호출을 하게 되면 페이지로딩을 다시 하므로 그 방법은 피했다)</p>]]></content>
      
      
        <tags>
            
            <tag> django </tag>
            
            <tag> ajax </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python에서 iOS, Android 스토어 인앱 결제 검증하기</title>
      <link href="/2016/03/11/store-inapp-in-python/"/>
      <url>/2016/03/11/store-inapp-in-python/</url>
      <content type="html"><![CDATA[<p>Django framework를 이용해서 프로젝트를 만들면서 했던 여러가지 삽질들과 넘어야했던 많은 산들과 몰랐던 부분들에 대해서 내 나름 공부 겸 기록을 위해 남겨둬야 겠다는 생각이 들었다. 프로젝트로 한창 바빴던 시기에는 당장 앞에 놓여진 일들에 치여 이런 생각을 못하고 있다가 지금은 조금 여유가 되어 그 때 있었던 일들에 대한 나름의 경험을 기록해보고자 한다.</p><p>그 중에 한가지가 인앱 아이템 결제하기 였다. 나는 예전에 cocos2d-x로 게임을 개발했던 시절엔 결제 프로세스를 클라이언트(단말기)사이드만 알고 있었고 서버사이드의 로직은 전혀 모르고 있었는데, 오히려 이번에 서버 로직을 구현하면서 그 때 그 시절의 경험이 많은 도움이 되었다. 앱 내에 아이템을 구매하고 구매한 아이템을 유저에게 잘 넣어주는 로직이야 구현방식도 다양하고 여러 기교들이 들어가 있는데 오늘은 그 중에서 나름 간단한(?) 파트인 두 플랫폼의 결제 영수증 검증 로직의 삽질 경험을 적어보고자 한다.</p><p>이번에 대응했던 클라이언트는 google play store와 iOS app store 두개의 플랫폼이다. 차례차례 훑어보자.<br>각 플랫폼별 스토어의 앱 등록과 각종 키발급 같은 내용은 다루지 않고 순수하게 영수증 검증만을 볼 것이다.</p><ol><li>google In-app billing<br>구글 결제 영수증 검증의 경우 생각보다 단순해서 처음에는 이게 맞나? 싶었다. 일반적으로 생각하기에는 구글의 결제서버에 영수증 정보를 넘겨 유효한 영수증인지 여부를 판단해서 진행이 되는줄 알았는데(이렇게 하는 방법도 있다고 한다.), 훨씬 간단한 방법이 있었다. 암호화된 영수증 정보를 클라이언트로 부터 받아와서 local에서 검증하는 방식이다.</li></ol><p>일단 pip를 이용해서 Crypto 라이브러리를 설치하도록 하자.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> pycrypto</span><br></pre></td></tr></table></figure><p>다음은 영수증 검증 코드이다. signed_data 는 안드로이드 결제완료시 넘어온 암호화된 영수증 문자열이고 signature는 클라이언트와 약속된 특정 문자열이다. 안드로이드에서 결제를 요청할 당시 이 값을 함께 넘겨주면 signed_data 내부에 이 signature 값이 심어들어가게 되고, 복호화를 하면 이 값이 풀어져 나와 영수증 검증을 할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> base64 <span class="keyword">import</span> b64decode</span><br><span class="line"><span class="keyword">from</span> Crypto.Hash <span class="keyword">import</span> SHA</span><br><span class="line"><span class="keyword">from</span> Crypto.PublicKey <span class="keyword">import</span> RSA</span><br><span class="line"><span class="keyword">from</span> Crypto.Signature <span class="keyword">import</span> PKCS1_v1_5</span><br><span class="line"></span><br><span class="line"><span class="comment"># Your base64 encoded public key from Google Play.</span></span><br><span class="line">PUBLIC_KEY_BASE64 = <span class="string">'YOUR_PUBLIC_KEY_BASE64'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">verify_for_google</span><span class="params">(signed_data, signature)</span>:</span></span><br><span class="line">    <span class="string">"""Returns whether the given data was signed with the private key."""</span></span><br><span class="line">    key = RSA.importKey(_pem_format(PUBLIC_KEY_BASE64))</span><br><span class="line">    verifier = PKCS1_v1_5.new(key)</span><br><span class="line">    data = SHA.new(signed_data.encode(<span class="string">'utf8'</span>))</span><br><span class="line">    sig = b64decode(signature)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> verifier.verify(data, sig)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_pem_format</span><span class="params">(key)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'\n'</span>.join([</span><br><span class="line">        <span class="string">'-----BEGIN PUBLIC KEY-----'</span>,</span><br><span class="line">        <span class="string">'\n'</span>.join(_chunks(key, <span class="number">64</span>)),</span><br><span class="line">        <span class="string">'-----END PUBLIC KEY-----'</span></span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_chunks</span><span class="params">(s, n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> range(<span class="number">0</span>, len(s), n):</span><br><span class="line">        <span class="keyword">yield</span> s[start:start+n]</span><br></pre></td></tr></table></figure><p>먼저 스토어에서 발급받은 공개키가 필요하다. 이 키를 이용해 넘어온 데이터가 유효한지 여부를 판단할 수 있다.</p><ol><li>RSA 암호 방식으로 암호화가 되어 있기 때문에 PUBLIC KEY 를 이용해 key객체를 생성한다.</li><li>PKCS(Public Key Cryptography Standard)를 이용해서 암호화된 영수증을 검증 할것이다. 1번에서 만들어진 key를 이용해 verifier 객체를 생성하자.</li><li>SHA(Secure Hash Algorithm)으로 된 signed_data를 객체로 생성한다.</li><li>signature 를 decode 한다.</li><li>2번에서 생성한 verifier를 통해 data 와 sig 의 유효성을 판단한다. 유효한 영수증은 True 그렇지 않으면 False 를 반환한다.<br>이 부분에 대해서는 좀 더 공부가 필요해 보인다… 현재는 암호화에 대한 꼭지들이 의미하는 바를 인지해야겠지만 이들이 어떤 작업을 하는지에 대한 공부도 반드시 필요할 것이다.<br>코드 내용이 그리 간단하지는 않지만 비교적 빠르게 구글 영수증 검증을 할 수 있었다. 구글의 개발자 사이트를 들어가 이런 저런 글도 읽오보고 여러 포스팅을 찾아보면서 여러가지 자료를 봐왔었는데 stackoverflow 에서 찾은 글들을 추려 간단하게 메소드로 정리했다. 내가 여기서 삽질 했던 부분은 대체 signed_data 와 signature 가 무엇을 뜻하는지 알 수가 없었다는 점이였다. 대부분의 자료들에서는 저 둘이 무엇을 의미하는지 자세히 기술을 해놓지 않거나 아예 어떤 값을 의미하는지를 써놓지 않은 글들이 많았다. 나도 처음에는 이리저리 고민을 해보다가 일단 맨땅에 헤딩을 하고보자는 마음으로 여러 땅에 삽집을 하다가 찾은 결과물이다.</li></ol><ol start="2"><li>iOS in-app purchase<br>이번에는 iOS결제 영수증 검증을 해보도록 하자. apple은 구글과는 다르게 결제 서버에 영수증을 보내서 넘어온 값을 통해 영수증의 유효성을 판단한다. 직접 apple의 결제 api를 호출해서 검증을 해도 되지만 역시나 Python은 있을만하다고 생각하는 라이브러리는 이미 존재하거나 누군가가 만들어 놨다. 우리는 이 라이브러리를 만든분 께 감사를 드리며 코드를 받아가도록 하자.</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> itunes-iap</span><br></pre></td></tr></table></figure><p>itunes-iap를 설치하면 의존성 라이브러리들이 이것저것 왕창 설치된다. 궁금하면 ($pip list 를 통해 확인해볼것)<br>이번에는 iOS 영수증 검증 코드를 보도록 하자. 이 때 transaction_id 는 결제 당시 결과값으로 오는 구매 영수증 id이고, raw_data는 암호화된 영수증 문자열이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itunesiap</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_verify_for_ios</span><span class="params">(transaction_id: str, raw_data: str)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    seeAlso : https://developer.apple.com/library/ios/releasenotes/General/ValidateAppStoreReceipt/Chapters/ValidateRemotely.html</span></span><br><span class="line"><span class="string">    :param transaction_id: 결제 transaction_id</span></span><br><span class="line"><span class="string">    :param raw_data: base64-encoded data</span></span><br><span class="line"><span class="string">    :return: boolean</span></span><br><span class="line"><span class="string">    :raises: Otherwise raise a request exception (RuntimeError, itunesiap.exc.InvalidReceipt)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># for sandbox environment.</span></span><br><span class="line">        <span class="comment">#     with itunesiap.env.sandbox:</span></span><br><span class="line">        <span class="comment">#         response = itunesiap.verify(raw_data)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># for production environment. (default)</span></span><br><span class="line">        response = itunesiap.verify(raw_data)  <span class="comment"># base64-encoded data</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">_get_key</span><span class="params">(re)</span>:</span></span><br><span class="line">            <span class="string">""" 영수증리스트에서 비교 키를 반환합니다. """</span></span><br><span class="line">            <span class="keyword">return</span> re.purchase_date_ms</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 넘어온 in_app 영수증 리스트에서 구매 시각이 가장 마지막인 영수증을 가져와서 transaction_id를 비교한다.</span></span><br><span class="line">        <span class="comment"># 오름 차순으로 정렬해서 구매시각이 가장 마지막 영수증을 가져옵니다.</span></span><br><span class="line">        receipts = sorted(response.receipt.in_app, key=_get_key)</span><br><span class="line">        last_receipt = receipts[len(receipts) - <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> last_receipt.transaction_id != transaction_id:</span><br><span class="line">            <span class="comment">#  구매시각이 가장 마지막인 영수증의 transaction_id 가 일치 하지 않는다.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> response.status == <span class="number">0</span></span><br></pre></td></tr></table></figure><p>iOS 영수증 유효성 검증은 간단하다. itunesiap.verify 메소드를 통해 iOS에서 넘어온 데이터를 넣고 호출하면 복호화된 영수증 데이터가 나온다. 이 때 status 값이 0 이라면 유효한 영수증이라고 판단한다. 뭔가 apple다운 api라고 생각한다. 처음 iOS영수증 검증을 할 당시엔 verify 메소드만 호출하고 그 뒤에 넘어온 데이터의 status 값만 확인하고 유효성을 검증했다.<br>여기서 나의 삽질이 시작되었다.</p><ol><li><p>일단 주석에서 보는것과 같이 sandbox환경과 real환경일 때에 호출하는 api가 다르다. itunesiap의 환경을 설정을 해주는 방법은 여러가지가 있다. 각자 개발환경에서 영수증 유효성을 검사할 때엔 sandbox와 real환경을 잘 구분해서 api를 호출해주도록 하자. 아무리 유효한 영수증이라 할지라도 틀린 환경의 api를 호출하면 유효하지 않다고 판단하기 때문이다.</p></li><li><p>보통 verify 메소드를 호출하면 receipt 값 안에 하나의 영수증 정보만 가져온다. 하지만 특정 상황의 경우 receipt 데이터 안에 1개 이상의 영수증 정보가 딸려 오는 경우가 있다. 이 때에 한가지 데이터만이 유효한 영수증 값이다. 이 중에서 한가지 영수증만을 가지고 검증을 해야 하는데 여러 삽질 후에 깨달은 바는 receipt 안의 데이터들의 purchase_date_ms 값을 이용해 가장 마지막에 결제된 영수증 정보가 파라메터로 넘어온 transaction_id 와 동일하다는 점을 알게 되었다. 그래서 _get_key 메소드를 통해 receipt 리스트를 정렬하고, 그 중에 가장 마지막 영수증 정보를 뽑아 transaction_id 가 같은지 여부를 판단한다.</p></li></ol><p>자 이제 우리는 python을 이용해서 android, iOS의 영수증을 검증할 수 있게 되었다. 간단하지도 복잡하지도 않고, 몰랐을 때는 어려워 난해했지만 알고나니 더 난해한 비교적 간단하게 할 수 있는 파트였다. 이제 어디가서 이 두 플랫폼의 결제 영수증쯤은 아무렇지도 않게 검증 할 수 있다고 당당히 얘기하자.</p>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> ios </tag>
            
            <tag> android </tag>
            
            <tag> inapp </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
