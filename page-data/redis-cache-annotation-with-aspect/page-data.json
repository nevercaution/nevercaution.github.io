{"componentChunkName":"component---src-templates-blog-post-index-js","path":"/redis-cache-annotation-with-aspect/","webpackCompilationHash":"86cef863552a4a2778d3","result":{"data":{"site":{"siteMetadata":{"title":"nevercaution","author":"nevercaution"}},"markdownRemark":{"id":"fc2f275b-7ee8-5aea-93ea-eae88a414406","html":"<h3>왜 만들었냐면..</h3>\n<p>이미 spring 에서 제공하는 <a href=\"https://docs.spring.io/spring/docs/4.1.x/spring-framework-reference/html/cache.html\">@Cacheable</a> 이 있다. 기능도 다양하고 <a href=\"https://docs.spring.io/spring/docs/4.3.10.RELEASE/spring-framework-reference/html/expressions.html\">Spel</a> 를 제공해서 좀 더 동적으로 캐싱을 할 수 있다. 캐싱을 받아주는 구현체만 추가해주면 되는데 redis 의 경우엔 <a href=\"https://docs.spring.io/spring-data/data-redis/docs/current/reference/html/\">spring-data-redis</a> 를 함께 사용하면 된다.\n처음에는 @Cacheable 를 사용해 구현해볼까 했는데 도입을 고려하는 시점에 있어 몇가지 사용의 불편함이 있었다.</p>\n<h4>현재 사내에서 사용하고 있는 캐싱키처럼의 생성이 까다롭다.</h4>\n<p>코드에서 동적으로 캐싱키를 만들어서 사용하고 있는데, 규격에 맞게 키가 생성되기 때문에 바로 도입시 중복되는 키가 두배로 많아져 부하가 생길 수 있다.</p>\n<h4>만료 시간을 캐시별로 주기가 어렵다.</h4>\n<p>@Cacheable 은 추상화되어 있는 구현체이다. redis 를 client 로 바로 사용은 가능하지만 나머지 부분은 일일히 설정을 해주거나 구현을 해주어야 한다. <a href=\"https://stackoverflow.com/questions/8181768/can-i-set-a-ttl-for-cacheable\">https://stackoverflow.com/questions/8181768/can-i-set-a-ttl-for-cacheable</a> 에서 보면 client 의 설정으로 가능하다고는 하지만 애초에 ttl 에 대한 구현은 따로 없기 때문에 우회하거나 획일화된 시간뿐이 줄 수 없다.</p>\n<h4>캐싱 로직을 가져갈 수 없다.</h4>\n<p>당연한 얘기겠지만 @Cacheable 을 사용하면 캐싱이 되는 로직은 사용자가 고려하지 않아도 된다. 문제는 여기 있는데 캐싱 로직에 원하는 코드를 추가하거나 수정할 수 없기 때문에 문제가 생기거나 로직이 변경되었을 때 대처가 불가능하다. 물론 애초에 @Cacheable 을 사용했다면 큰 문제가 없었겠지만 입맛에 맞게 캐싱 로직을 편하게 만들 필요가 있었다.</p>\n<p>기존에 사용하고 있는 캐싱 로직이 있다. method 를 invoke 해서 method 키값으로 결과물들을 redis 에 담아서 사용하고 있었는데, 이를 좀 더 사용하기 편하게 하기 위해 custom annotation 를 만들어서 사용하고자 했다.\n(결국 @Cacheable 를 뜯어보다가 필요한 부분만 뽑아서 따로 만들게 되었다.)</p>\n<h3>구현 목적</h3>\n<p>@RedisCached annotation 이 붙은 method 들에 대해 설정된 값에 따라 캐싱을 할 수 있고 필요에 따라 파라미터 값들도 함께 사용해야 한다면 @RedisCachedKeyParam 를 사용해서 method 의 parameter 와 value 를 함께 cache key 로 사용할 수 있다. 사용예제는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"java\">\n      <pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Service</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">PersonService</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token annotation punctuation\">@RedisCached</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">=</span> <span class=\"token string\">\"person\"</span><span class=\"token punctuation\">,</span> expire <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">public</span> <span class=\"token class-name\">Person</span> <span class=\"token function\">getPerson</span><span class=\"token punctuation\">(</span><span class=\"token annotation punctuation\">@RedisCachedKeyParam</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">=</span> <span class=\"token string\">\"name\"</span><span class=\"token punctuation\">)</span> <span class=\"token class-name\">String</span> name<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token comment\">// do make cache jobs</span>\n        <span class=\"token class-name\">Person</span> person <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Person</span><span class=\"token punctuation\">(</span>name<span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token class-name\">System</span><span class=\"token punctuation\">.</span>out<span class=\"token punctuation\">.</span><span class=\"token function\">println</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"person = \"</span> <span class=\"token operator\">+</span> person<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> person<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<p>method 내부에서는 db job 이나 비용이 큰 작업들을 처리해주고 cache 대한 처리는 annotation 으로 처리한다.</p>\n<h3>구현해보자.</h3>\n<h4>1. build.gradle</h4>\n<div class=\"gatsby-highlight\" data-language=\"gradle\">\n      <pre class=\"language-gradle\"><code class=\"language-gradle\">...\ndependencies {\n    compile(&quot;org.springframework.boot:spring-boot-starter-web&quot;)\n    compile(&#39;org.springframework:spring-aspects&#39;)\n    compileOnly(&#39;org.projectlombok:lombok&#39;)\n    compile(&#39;redis.clients:jedis:3.0.1&#39;)\n    compile(&#39;com.google.code.gson:gson:2.8.0&#39;)\n    compile(&#39;com.google.guava:guava:22.0&#39;)\n    testCompile(&#39;org.springframework.boot:spring-boot-starter-test&#39;)\n}</code></pre>\n      </div>\n<p>sprong-aop 를 사용해서 @RedisCached annotation 이 붙은 method 들을 가져와서 캐싱 로직을 태울 수 있다.</p>\n<h4>@RedisCached</h4>\n<div class=\"gatsby-highlight\" data-language=\"java\">\n      <pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span>value <span class=\"token operator\">=</span> <span class=\"token class-name\">ElementType</span><span class=\"token punctuation\">.</span>METHOD<span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RetentionPolicy</span><span class=\"token punctuation\">.</span>RUNTIME<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token annotation punctuation\">@interface</span> <span class=\"token class-name\">RedisCached</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token comment\">/**\n     * main cache key name\n     * @return\n     */</span>\n    <span class=\"token class-name\">String</span> <span class=\"token function\">key</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/**\n     * expire time\n     * @return\n     */</span>\n    <span class=\"token keyword\">int</span> <span class=\"token function\">expire</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token number\">1800</span><span class=\"token punctuation\">;</span>\n\n    <span class=\"token comment\">/**\n     * force proceed method\n     * @return\n     */</span>\n    <span class=\"token keyword\">boolean</span> <span class=\"token function\">replace</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">default</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<ul>\n<li>key : 캐싱이 되는 메인 키값을 줄 수 있다.</li>\n<li>expire : 만료가 되는 시점을 줄 수 있다. 기본설정은 1800초이다.</li>\n<li>replace : 캐싱 값을 덮어씌울지 여부이다. 필요에 따라 레디스에 저장되어 있는 값들을 override 해줄 때 사용한다.</li>\n</ul>\n<h4>@RedisCachedKeyParam</h4>\n<div class=\"gatsby-highlight\" data-language=\"java\">\n      <pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Target</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">ElementType</span><span class=\"token punctuation\">.</span>PARAMETER<span class=\"token punctuation\">)</span>\n<span class=\"token annotation punctuation\">@Retention</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">RetentionPolicy</span><span class=\"token punctuation\">.</span>RUNTIME<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">public</span> <span class=\"token annotation punctuation\">@interface</span> <span class=\"token class-name\">RedisCachedKeyParam</span> <span class=\"token punctuation\">{</span>\n\n    <span class=\"token class-name\">String</span> <span class=\"token function\">key</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre>\n      </div>\n<p>method parameter 에 붙여서 사용한다. @RedisCached.key 와 더불어 캐싱키값을 만들고자 할 때 사용한다.</p>\n<h4>RedisCacheAspect.class</h4>\n<div class=\"gatsby-highlight\" data-language=\"text\">\n      <pre class=\"language-text\"><code class=\"language-text\">@Component\n@Aspect\npublic class RedisCacheAspect {\n    private static Map&lt;String, RedisCacheParameterMethodInfo&gt; cacheParameterMethodInfoMap = new HashMap&lt;&gt;();\n\n    @Autowired\n    private RedisDB redisDB;\n\n    // point1\n    @Around(value = &quot;execution(* *(..)) &amp;&amp; @annotation(redisCached)&quot;)\n    public Object aroundAspect(ProceedingJoinPoint joinPoint, RedisCached redisCached) {\n\n        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();\n        Method method = methodSignature.getMethod();\n        String methodName = method.getName();\n\n        Class returnType = methodSignature.getReturnType();\n\n        // point2\n        String key = redisCached.key();\n        int expire = redisCached.expire();\n        boolean replace = redisCached.replace();\n\n        // point3\n        // reflect caching key from parameter\n        List&lt;String&gt; parameterKeyList = new ArrayList&lt;&gt;();\n        Object[] args = joinPoint.getArgs();\n        RedisCacheParameterMethodInfo methodInfo = cacheParameterMethodInfoMap.get(methodName);\n        if (methodInfo != null) {\n            List&lt;RedisCacheParameterMethodInfo.IndexInfo&gt; indexInfoList = methodInfo.getIndexInfoList();\n            indexInfoList.forEach(info -&gt;\n                    parameterKeyList.add(makeCacheKey(info.getAnnotation(), args[info.getIndex()].toString())));\n\n        } else {\n            methodInfo = new RedisCacheParameterMethodInfo();\n            Annotation[][] parameterAnnotations = method.getParameterAnnotations();\n            for (int i = 0; i &lt; parameterAnnotations.length; i++) {\n                for (Annotation annotation : parameterAnnotations[i]) {\n                    if (annotation instanceof RedisCachedKeyParam) {\n                        RedisCachedKeyParam keyParam = (RedisCachedKeyParam)annotation;\n                        parameterKeyList.add(makeCacheKey(keyParam, args[i].toString()));\n                        methodInfo.addInfo(keyParam, i);\n                    }\n                }\n            }\n            cacheParameterMethodInfoMap.put(methodName, methodInfo);\n        }\n\n        // point5\n        // make cache key\n        StringBuilder cacheKeyBuilder = new StringBuilder()\n                .append(key).append(&quot;/&quot;).append(methodName).append(&quot;/&quot;);\n\n        if (!CollectionUtils.isEmpty(parameterKeyList)) {\n            cacheKeyBuilder.append(Joiner.on(&quot;,&quot;).join(parameterKeyList));\n        }\n        final String cacheKey = cacheKeyBuilder.toString();\n\n        try {\n            Object result;\n            // point6\n            if (!replace) {\n                Long ttl = redisDB.ttl(cacheKey);\n                if (ttl &gt; 0) {\n\n                    result = redisDB.get(cacheKey, returnType);\n                    return result;\n                }\n            }\n\n            // point7\n            result = joinPoint.proceed();\n            redisDB.set(cacheKey, result, returnType);\n            redisDB.expire(cacheKey, expire);\n\n            return result;\n        } catch (Throwable t) {\n            t.printStackTrace();\n        }\n\n        return null;\n    }\n\n    // point 4\n    private String makeCacheKey(RedisCachedKeyParam keyParam, String value ) {\n        return String.format(&quot;%s=%s&quot;, keyParam.key(), value);\n    }\n}</code></pre>\n      </div>\n<p>핵심이 되는 캐싱 구현로직이다. 포인트 별로 살펴보자.</p>\n<ul>\n<li>point1 : spring-aop 를 사용해서 @Around 로 묶어서 사용한다. @RedisCached 가 붙어 있는 method 들에 대해 캐싱 로직을 태운다.</li>\n<li>point2 : @RedisCached 에 있는 값들을 가져와서 캐시키나 만료에 대한 정보들을 가져온다.</li>\n<li>point3 : cacheKey 를 만들어 줄때 method 에 들어있는 parameter 들을 가져와서 만들어주는데 이를 매번 joinPoint 에서 가져와서 reflect 할 필요는 없다. 별도의 hashMap 을 갖고 이미 reflect 된 method 들에 대해서는 갖고 있는 값을 사용하도록 한다.</li>\n<li>point4 : method 에서 parameter 들을 가져와서 @RedisCachedKeyParam 와 연결을 시켜 캐싱키를 만들어 준다.</li>\n<li>point5 : 캐싱키는 <code class=\"language-text\">person/getPerson/name=teddy</code> 와 같이 사용하고 있다. @RedisCached.key 와 methodName, @RedisCachedKeyParam 에 설정되어 있는 key, value 를 붙여서 사용하고 있는데 이를 만들어 주는 과정이다.</li>\n<li>point6 : @RedisCached.replace 로 이미 캐시가 되어 있는 값을 덮어 쓸지 여부에 대한 로직이다. 주기적으로 갱신이 필요한 캐싱들에 대해 값을 덮어 써줄 수 있다. point6 의 분기를 타지 않으면 proceed() 된 값을 cacheKey 에 덮어씌운다.</li>\n<li>point7 : 실제 redis 에 캐싱이 되는 부분이다. 이미 캐싱이 되어 있다면 point6 의 분기에서 redis 의 저장되어 있는 값을 반환한다.</li>\n</ul>\n<h3>사용해보기</h3>\n<div class=\"gatsby-highlight\" data-language=\"bash\">\n      <pre class=\"language-bash\"><code class=\"language-bash\">$❯ <span class=\"token function\">curl</span> localhost:8080/person/teddy\n<span class=\"token punctuation\">{</span><span class=\"token string\">\"name\"</span><span class=\"token keyword\">:</span><span class=\"token string\">\"teddy\"</span>,<span class=\"token string\">\"age\"</span>:10<span class=\"token punctuation\">}</span>\n\n-- log\n\n// call mapping\nperson <span class=\"token operator\">=</span> Person<span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span>teddy, age<span class=\"token operator\">=</span>10<span class=\"token punctuation\">)</span>\n// <span class=\"token function\">make</span> cache\ngetPerson <span class=\"token operator\">=</span> Person<span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span>teddy, age<span class=\"token operator\">=</span>10<span class=\"token punctuation\">)</span>\n// use cache\ngetPerson <span class=\"token operator\">=</span> Person<span class=\"token punctuation\">(</span>name<span class=\"token operator\">=</span>teddy, age<span class=\"token operator\">=</span>10<span class=\"token punctuation\">)</span>\n\n-- redis\n127.0.0.1:6379<span class=\"token operator\">></span> get person/getPerson/name<span class=\"token operator\">=</span>teddy\n<span class=\"token string\">\"{\\\"name\\\":\\\"teddy\\\",\\\"age\\\":10}\"</span>\n127.0.0.1:6379<span class=\"token operator\">></span> ttl person/getPerson/name<span class=\"token operator\">=</span>teddy\n<span class=\"token punctuation\">(</span>integer<span class=\"token punctuation\">)</span> 187</code></pre>\n      </div>\n<p>api 콜을 하면 redis 에 저장되어 있는지 여부를 검사하고 해당 키값으로 값이 없으면 캐싱을 하고 돌려준다. 그 다음부터 호출을 하면 redis 에 저장되어 있는 값을 돌려준다.</p>\n<h3>한계가 있다!</h3>\n<p>spring-aop 를 사용하고 있는데 proxy 기반으로 동작하기 때문에 inner method 호출은 먹지 않는다. <a href=\"https://stackoverflow.com/questions/13564627/spring-aop-not-working-for-method-call-inside-another-method\">https://stackoverflow.com/questions/13564627/spring-aop-not-working-for-method-call-inside-another-method</a> 에서 보면 우회적으로 해결할 수 있는 방법들이 있는데 좋아보이지는 않는다. 아예 aspectJ 를 이용해서 구현해볼까도 생각중이긴 한데 아직 완전한 해결방법은 찾이 못했다. 이는 interface 로 캐싱 로직을 따로 빼거나 우회적인 방법으로 임시적인 해결을 할 수는 있지만 여전히 inner method call 이 안되는건 마음에 들지 않는다.</p>\n<h3>결론</h3>\n<p>@RedisCached 를 이용해서 기존의 캐시 전략을 따라가면서 조금 더 사용이 편한 방법으로 구현이 되었다. 다만 명확한 한계점이 있어 반쪽짜리 캐시긴 하지만.. <a href=\"https://medium.com/chequer/spring-transactional-caching-%EA%B7%B8%EB%A6%AC%EA%B3%A0-aspectj-2%ED%8E%B8-aspectj-689319db329f\">LTW 사용하기</a> 와 같은 좋은 블로그등을 참고해서 해결방안을 모색중이다. 위의 예제코드는 <a href=\"https://github.com/nevercaution/cachedTest\">Example code</a> 에서 확인할 수 있다.</p>","excerpt":"왜 만들었냐면..이미 spring 에서 제공하는 @Cacheable 이 있다. 기능도 다양하고 Spel 를 제공해서 좀 더 동적으로 캐싱을 할 수 있다. 캐싱을 받아주는 구현체만 추가해주면 되는데 redis 의 경우엔 spring-data-redis…","frontmatter":{"title":"redis cache 를 @annotation 으로 하기 (with @Aspect)","date":"2019-02-03","tags":["springboot","redis","jedis","customannotation","aspect","gradle"],"keywords":["spring boot cache"]}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/redis-cache-annotation-with-aspect/","previous":{"fields":{"slug":"/retrofit-with-spring-boot/"},"frontmatter":{"title":"spring boot 에서 Retrofit 사용해보기","tags":["springboot","retrofit2","okhttp3","async"],"published":true}},"next":{"fields":{"slug":"/spring-boot-starter-custom/"},"frontmatter":{"title":"Spring Boot Starter Customize 하기","tags":["springboot","maven","spring","autoconfigure","boot","custom"],"published":true}}}}}